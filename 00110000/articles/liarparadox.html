<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Resolving the Liar Paradox Using the Category-Theoretic Framework of Subjective Numbers</title>
    <meta name="description"
        content="Resolving the Liar Paradox Using the Category-Theoretic Framework of Subjective Numbers" />
    <link href="article-style.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="../../images/favicon.png">


    <style>
        /* Basic Table and Code Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1em 0;
            font-size: 18px;
        }

        th,
        td {
            border: 1px solid #aaa;
            padding: 0.5em;
            text-align: left;
        }

        th {
            background-color: #ddd;
        }

        .formula {
            font-size: 18px;
            margin: 0.5em 0;
            font-style: italic;
        }

        .code {
            font-family: monospace;
            background-color: #eee;
            padding: 0.2em 0.5em;
            border-radius: 3px;
        }

        .important {
            padding: 0.5em;
            border-radius: 5px;
            margin: 0.5em 0;
        }

        .callout {
            border: 2px dashed #888;
            padding: 1em;
            margin: 1em 0;
        }

        .callout h3 {
            margin-top: 0;
        }

        /* Additional styling to highlight new sections or examples */
        .example-box {
            border: 1px solid #bbb;
            border-left: 5px solid #000000;
            background-color: #f9f9f9;
            padding: 1em;
            margin: 1em 0;
        }

        .theorem {
            background-color: #f5f5f5;
            padding: 1em;
            margin: 1em 0;
            font-size: 1.2em;

            border-left: 4px solid #333;
        }

        .complete-proof {
            padding: 0 1em;
            margin: 1em 0;
            border-left: 2px solid #777;
        }

        /* Mathematical notation styles */
        .math {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
        }

        .math-op {
            font-family: 'Times New Roman', Times, serif;
            font-style: normal;
        }

        .math-set {
            font-family: 'Times New Roman', Times, serif;
            font-style: normal;
            font-weight: bold;
        }

        .math-subscript {
            position: relative;
            bottom: -0.3em;
            font-size: 0.8em;
        }

        .math-block {
            display: block;
            text-align: center;
            margin: 1em 0;
            font-size: 18px;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="logo-container">
            <a href="../../index.html" style="text-decoration: none; color: inherit;">
                <h1 class="logo-text">Cinematic Strawberry</h1>
            </a>
            <a href="../../index.html">
                <img src="../../images/logo.jpg" alt="Logo" class="logo-image" />
            </a>
        </div>
        <nav>
            <ul>

                <li><a href="../../index.html">Look In The Eye</a></li>
                <li><a href="../../00110000.html">Universe 00110000</a></li>
            </ul>
        </nav>
    </div>
    <div class="banner">
        <img src="images/liar_paradox_banner.jpg" alt="Liar Paradox Banner Image" />
    </div>

    <article>
        <h1>Resolving the Liar Paradox Using the Category-Theoretic Framework of Subjective Numbers</h1>
        <hr />

        <!-- =================== ABSTRACT =================== -->
        <h2>Abstract</h2>
        <p>
            We present a novel resolution of the classic liar paradox through a category-theoretic framework of
            <a href="subjectivenumbers.html"
                style="text-decoration: none; border-bottom: 1px solid transparent; transition: border-bottom 0.3s;"
                onmouseover="this.style.borderBottomColor='black';"
                onmouseout="this.style.borderBottomColor='transparent';">
                subjective numbers</a>. In our approach, each statement is naturally associated with a perspective (its
            vantage point),
            and these perspectives are the objects in our category.
            Morphisms then represent transitions between perspectives,
            capturing how statements are evaluated cross-perspectivally.

            Self-reference is reinterpreted as a controlled cyclic composition of these morphisms.
            In particular, the paradoxical sentence ‚ÄúThis statement is false‚Äù is reformulated as a morphism
            whose evaluation involves composing a ‚Äútruth-evaluation‚Äù morphism with a ‚Äúcomplement‚Äù morphism.
            This yields a cycle in which truth values oscillate between a value and its negation
            in a manner that is locally consistent (within each perspective) and immune to paradoxical explosion.
            We rigorously develop the framework defining the underlying category, establishing key axioms,
            and proving essential theorems, and compare our approach with traditional semantic hierarchies
            and fixed-point methods. Finally, we discuss connections to modal and multi-valued logics,
            and outline future research directions. Our set-theoretically sound framework demonstrates
            that the liar paradox is not a fundamental inconsistency but a manifestation of the inherent
            perspective-dependence of self-referential truth.
        </p>

        <!-- =================== NOTATION TABLE =================== -->
        <h3>Notation Guide</h3>
        <table style="width: 80%; margin: 1em auto;">
            <tr>
                <th>Symbol</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><span class="math">L</span></td>
                <td>The liar statement "This statement is false"</td>
            </tr>
            <tr>
                <td><span class="math">œÑ(L)</span></td>
                <td>Truth value of statement <span class="math">L</span></td>
            </tr>
            <tr>
                <td><span class="math-set">P</span></td>
                <td>Set of perspectives</td>
            </tr>
            <tr>
                <td><span class="math">p, q, r, s, t</span></td>
                <td>Elements of <span class="math-set">P</span> (specific perspectives)</td>
            </tr>
            <tr>
                <td><span class="math">p<sub>L</sub></span></td>
                <td>Intrinsic perspective of the liar statement</td>
            </tr>
            <tr>
                <td><span class="math">p<sub>E</sub></span></td>
                <td>An external evaluative perspective</td>
            </tr>
            <tr>
                <td><span class="math-set">V</span></td>
                <td>Value space (typically Boolean algebra <span class="math">{true, false}</span>)</td>
            </tr>
            <tr>
                <td><span class="math">a, b, c</span></td>
                <td>Elements of <span class="math-set">V</span> (truth values)</td>
            </tr>
            <tr>
                <td><span class="math">a<sub>(p)</sub></span></td>
                <td>Subjective number with value <span class="math">a</span> and perspective <span class="math">p</span>
                </td>
            </tr>
            <tr>
                <td><span class="math">=<sub>p</sub></span></td>
                <td>Subjective equality relation from perspective <span class="math">p</span></td>
            </tr>
            <tr>
                <td><span class="math">f<sub>(a, p ‚Üí q)</sub></span></td>
                <td>Morphism representing transition from perspective <span class="math">p</span> to <span
                        class="math">q</span> with truth value <span class="math">a</span></td>
            </tr>
            <tr>
                <td><span class="math">f<sub>((a,b), p ‚Üí r)</sub></span></td>
                <td>Composite morphism with value history (<span class="math">a</span> from <span class="math">p</span>,
                    <span class="math">b</span> from intermediate perspective)
                </td>
            </tr>
            <tr>
                <td><span class="math">R<sub>p</sub></span></td>
                <td>Relation function associated with perspective <span class="math">p</span></td>
            </tr>
            <tr>
                <td><span class="math">CPA<sub>p</sub></span></td>
                <td>Cross-perspective adoption function for perspective <span class="math">p</span></td>
            </tr>
            <tr>
                <td><span class="math">id<sub>p</sub></span></td>
                <td>Identity morphism for perspective <span class="math">p</span></td>
            </tr>
            <tr>
                <td><span class="math">¬¨</span></td>
                <td>Boolean negation in value space <span class="math-set">V</span></td>
            </tr>
            <tr>
                <td><span class="math">true<sub>0</sub></span></td>
                <td>Identity element in value space <span class="math-set">V</span> for logical operations</td>
            </tr>
            <tr>
                <td><span class="math">ùì¢ùìù</span></td>
                <td>Category of subjective numbers</td>
            </tr>
            <tr>
                <td><span class="math">‚â°</span></td>
                <td>Equivalence relation on morphisms</td>
            </tr>
            <tr>
                <td><span class="math">‚àº</span></td>
                <td>Equivalence relation on value histories</td>
            </tr>
        </table>

        <!-- =================== INTRO SECTION =================== -->
        <h2>1. Introduction</h2>

        <h3>1.1 The Liar Paradox and Its Significance</h3>
        <p>
            The liar paradox, instantiated by the self-referential statement "This statement is false," challenges the
            fundamental assumption that every statement must have a determinate truth value. If we assign the truth
            value <span class="math">true</span> to the statement, then its assertion forces it to be <span
                class="math">false</span>; if we assign <span class="math">false</span>, the statement then becomes
            <span class="math">true</span>. This contradiction has profound implications for semantics, the nature of
            truth, and the logical foundations of formal systems.
        </p>
        <p>
            The paradox has been a central concern in logic and philosophy of language for over two millennia. From
            Epimenides of Crete in ancient Greece to modern mathematical logic, this seemingly simple self-referential
            statement has challenged our understanding of truth and formal systems. Its significance extends beyond pure
            logic to impact theories of meaning, formal semantics, foundations of mathematics, and computational theory.
        </p>
        <p>
            A particularly important feature of the liar paradox is that it arises within ordinary language and
            reasoning, not requiring specialized logical machinery or exotic mathematical concepts. This naturalness
            suggests that the paradox reveals something fundamental about the nature of truth and self-reference that
            cannot be dismissed as mere formalism.
        </p>
        <p>
            Our framework identifies the fundamental source of the liar paradox: the implicit attempt to force multiple,
            inherently contradicting viewpoints into a single universal perspective. When a statement refers to itself,
            it necessarily creates two distinct vantage points: the <em>intrinsic perspective</em> <span
                class="math">p<sub>L</sub></span>
            (the vantage point of the statement itself) and the <em>external evaluative perspective</em> <span
                class="math">p<sub>E</sub></span>
            (the vantage point from which the statement is evaluated). This division is not an artificial construct but
            a natural
            consequence of self-reference itself.
        </p>
        <p>
            For a statement to evaluate its own truth value, it must simultaneously exist as both the object being
            evaluated and participate in the process of evaluation‚Äîdual roles that cannot collapse into a single
            perspective without generating contradiction. Traditional approaches treat the paradox as a problem with
            self-reference itself or with classical logic, but we argue it is more accurately understood as a category
            error‚Äîattempting to collapse a process that necessarily spans multiple perspectives into a static,
            universal evaluation. By explicitly modeling these distinct perspectives and the transitions between them,
            we reveal that the apparent contradiction is actually a well-defined cycle distributed across perspectives,
            with no single perspective ever holding contradictory beliefs.
        </p>
        <h3>1.2 Traditional Approaches and Their Limitations</h3>
        <p>
            Several major strategies have been developed to resolve the liar paradox, each with significant limitations:
        </p>
        <ul style="font-size: 18px;">
            <li><strong>Semantic Hierarchies (Tarski):</strong> Alfred Tarski proposed that the truth predicate cannot
                be consistently defined within the language to which it applies. Instead, truth must be defined in a
                hierarchy of meta-languages. This approach effectively blocks self-reference by prohibiting a language
                from containing its own truth predicate. While logically sound, Tarski's hierarchy is widely criticized
                for being artificial and incompatible with the natural way language functions, where self-reference is
                common and unproblematic in most contexts.</li>
            <li><strong>Fixed-Point Theories (Kripke):</strong> Saul Kripke developed an approach where truth values are
                assigned in stages, treating the liar sentence as neither true nor false but "ungrounded." This allows
                for a limited form of self-reference but introduces a third truth value or "truth-value gap." While more
                permissive than Tarski's approach, Kripke's solution still restricts the expressiveness of the language
                and struggles with "strengthened" versions of the paradox.</li>
            <li><strong>Paraconsistent Logics:</strong> These systems allow for local contradictions without leading to
                global inconsistency by restricting the principle of explosion (ex falso quodlibet). Graham Priest's
                dialetheism, for instance, accepts that the liar sentence is both true and false. While this preserves
                expressive power, it requires abandoning fundamental principles of classical logic that many
                philosophers and mathematicians are unwilling to relinquish.</li>
            <li><strong>Revision Theories:</strong> Developed by Anil Gupta and Nuel Belnap, revision theories treat
                truth as a circular concept whose extension is continuously revised. The liar sentence oscillates
                between truth values through an infinite sequence of revisions. This approach captures the dynamic
                nature of the paradox but requires complex transfinite sequences and does not provide a stable final
                truth value.</li>
            <li><strong>Contextualist Approaches:</strong> These theories argue that the liar sentence implicitly refers
                to different contexts or contains hidden indexicals. While intuitive, contextualist approaches often
                struggle to precisely formalize how contexts shift without introducing an ad hoc mechanism specifically
                designed to block the paradox.</li>
        </ul>
        <p>
            A common limitation across these approaches is that they treat self-reference and perspective as secondary
            or problematic features to be controlled or eliminated, rather than as intrinsic aspects of truth
            evaluation. This hints at the need for a more fundamental rethinking of how truth values relate to
            self-reference and perspective.
        </p>

        <h3>1.3 A Novel Perspective-Dependent Approach</h3>
        <p>
            In contrast to previous approaches, we introduce a framework based on subjective numbers mathematical
            objects that incorporate an intrinsic perspective. Rather than treating perspective as an external label,
            our framework embeds it directly into mathematical objects via a category-theoretic construction. In this
            framework, each statement is represented as a morphism between perspectives, and truth evaluation is
            performed through the composition of these morphisms.
        </p>
        <p>
            The liar statement, in particular, is modeled by a morphism that, through a controlled composition with a
            complementing morphism, yields a cyclic structure that "oscillates" between a truth value and its
            complement. This controlled cyclicity ensures that while the overall structure is non-classical, local
            evaluations remain consistent with classical logic.
        </p>
        <p>
            Our approach differs fundamentally from previous ones in that:
        </p>
        <ol style="font-size: 18px;">
            <li><strong>Intrinsic Perspective:</strong> Perspective is treated as intrinsic to mathematical objects
                rather than as an external parameter or afterthought</li>
            <li><strong>Natural Self-Reference:</strong> Self-reference is modeled as a natural cycle of perspective
                transitions rather than as a problematic feature to be eliminated</li>
            <li><strong>Categorical Composition:</strong> Truth evaluation is performed through categorical composition
                of morphisms rather than through hierarchical layering or fixed-point construction</li>
            <li><strong>Local Classical Logic:</strong> Classical logic is preserved within each perspective, with
                non-classical behavior arising only in cross-perspective evaluation</li>
            <li><strong>Full Expressiveness:</strong> The framework retains full expressiveness while ensuring local
                consistency, without requiring the introduction of truth-value gaps or gluts</li>
        </ol>
        <p>
            This novel approach allows us to reinterpret the liar paradox not as a contradiction requiring restriction
            or revision of our logical framework, but as a naturally occurring cycle within a more expressive
            mathematical structure that properly accounts for the perspective-dependent nature of self-referential
            truth.
        </p>

        <div class="figure">
            <img src="images/liar_paradox3.jpg" alt="Cyclical Nature of Liar Paradox" />
            <p class="caption">Cyclical Nature of the Liar Paradox</p>
        </div>

        <div class="key-takeaways">
            <h3>Key Takeaways: Introduction</h3>
            <ul style="font-size: 18px;">

                <li>The liar paradox reveals fundamental issues with our understanding of truth and self-reference</li>
                <li>Traditional approaches (Tarski, Kripke, paraconsistent logics) all sacrifice something valuable:
                    either expressiveness, classical logic, or simplicity</li>
                <li>Our framework treats perspective as intrinsic to mathematical objects, not as an external parameter
                </li>
                <li>Self-reference is reinterpreted as a cycle of perspective transitions, maintaining local consistency
                </li>
                <li>This approach preserves classical logic within each perspective while allowing for the natural
                    expression of self-reference</li>
            </ul>
        </div>

        <!-- =================== CALL-OUT: PERSPECTIVE-DEPENDENT TRUTH =================== -->
        <div class="callout">
            <h3>Perspective-Dependent Truth</h3>
            <p>
                <strong>Classical Approach:</strong> Traditional logic assumes truth is absolute and
                perspective-independent, where mathematical truths are independent of observer or context. This has led
                to difficulties when dealing with self-referential statements like the liar
                paradox.
            </p>
            <p>
                <strong>Subjective Numbers' Perspective:</strong> In our framework, mathematical objects have intrinsic
                perspectives that govern their relationships. The liar paradox becomes a controlled cycle of
                perspective shifts rather than a contradiction, preserving local consistency while allowing for the
                natural expression of self-reference.
            </p>
        </div>

        <!-- =================== LIAR PARADOX =================== -->
        <h2>2. The Liar Paradox and Traditional Approaches</h2>

        <h3>2.1 Formal Derivation of the Paradox</h3>
        <p>
            Let <span class="math">L</span> denote the liar statement "This statement is false." To analyze the paradox
            rigorously, we introduce a truth evaluation function <span class="math">œÑ</span> that maps statements to
            truth values in the set <span class="math">{true, false}</span>. By the content of <span
                class="math">L</span>, we have:
        </p>
        <div class="math-block">
            <span class="math">œÑ(L) = false</span>
        </div>
        <p>
            However, this defining equation creates an inherent circularity: the truth value of <span
                class="math">L</span> is determined by the content of <span class="math">L</span> itself, which refers
            to its own truth value. Let's consider both possible cases:
        </p>
        <ol style="font-size: 18px;">
            <li>If we assume <span class="math">œÑ(L) = true</span>, then by definition <span class="math">L</span>
                must be true. But <span class="math">L</span> asserts that it is false, so <span class="math">œÑ(L) =
                    false</span>, contradicting our assumption.</li>
            <li>If we assume <span class="math">œÑ(L) = false</span>, then by definition <span class="math">L</span>
                must be false. But if <span class="math">L</span> is false, then its claim (that it is false) must be
                incorrect, meaning <span class="math">œÑ(L) = true</span>, again yielding a contradiction.</li>
        </ol>
        <p>
            In short, we obtain the paradoxical relation:
        </p>
        <div class="math-block">
            <span class="math">œÑ(L) = ¬¨œÑ(L)</span>
        </div>
        <p>
            where <span class="math">¬¨</span> denotes logical negation. This biconditional creates a direct
            contradiction a statement cannot be equivalent to its own negation in classical logic.
        </p>

        <div class="example-box">
            <h3>Example 2.1: A Simple Liar Paradox</h3>
            <p>Consider the statement L: "This statement is false."</p>
            <p>If we try to evaluate L's truth value:</p>
            <ul style="font-size: 18px;">

                <li>Assume L is true ‚Üí L's content must be true ‚Üí L is false ‚Üí Contradiction</li>
                <li>Assume L is false ‚Üí L's content must be false ‚Üí L is true ‚Üí Contradiction</li>
            </ul>
            <p>Classical logic provides no consistent truth assignment for L.</p>
        </div>

        <p>
            The paradox is particularly troubling because it appears to use only seemingly innocent logical principles:
        </p>
        <ul style="font-size: 18px;">
            <li><strong>Bivalence:</strong> The principle that every statement has a definite truth value (either true
                or false)</li>
            <li><strong>Truth Schema:</strong> The principle that a statement "X is true" is true if and only if X is
                true</li>
            <li><strong>Self-Reference:</strong> The legitimacy of statements referring to themselves</li>
            <li><strong>Classical Logic:</strong> Standard laws including the law of excluded middle, the law of
                non-contradiction, and rules of inference</li>
        </ul>
        <p>
            The apparent contradiction suggests that at least one of these principles must be rejected or modified to
            avoid inconsistency. Each traditional approach to resolving the paradox chooses different principles to
            sacrifice.
        </p>

        <h3>2.2 Traditional Semantic Hierarchies and Fixed-Point Solutions</h3>
        <p>
            We now examine two major traditional solutions to the liar paradox in more detail, to better contrast them
            with our category-theoretic approach:
        </p>

        <h3>2.2.1 Semantic Hierarchies (Tarski)</h3>
        <p>
            Alfred Tarski proposed that the truth predicate cannot be consistently defined within the language to which
            it applies. Instead, truth must be defined in a meta-language:
        </p>
        <ul style="font-size: 18px;">
            <li>Language <span class="math">L<sub>0</sub></span> contains no truth predicate</li>
            <li>Language <span class="math">L<sub>1</sub></span> contains a truth predicate <span
                    class="math">True<sub>1</sub></span> that
                can be applied only to sentences in <span class="math">L<sub>0</sub></span></li>
            <li>Language <span class="math">L<sub>2</sub></span> contains a truth predicate <span
                    class="math">True<sub>2</sub></span> that
                can be applied only to sentences in <span class="math">L<sub>1</sub></span></li>
            <li>And so on, creating an infinite hierarchy of languages and truth predicates</li>
        </ul>
        <p>
            In this framework, the liar paradox is blocked because a statement cannot refer to its own truth. The
            statement "This statement is false" would need to be formulated as "This statement is not True<sub>n</sub>"
            for some level <span class="math">n</span>, but then the statement itself would belong to level <span
                class="math">n+1</span>, making the self-reference impossible.
        </p>
        <p>
            <strong>Limitations:</strong> While Tarski's approach successfully avoids the paradox, it does so by
            severely restricting self-reference, which is a natural and common feature of ordinary language. The
            hierarchy also introduces significant complexity, requiring an infinite tower of languages and truth
            predicates that has no analog in natural language. Moreover, since natural language appears capable of
            self-reference without collapsing into contradiction in most cases, the Tarskian solution seems overly
            restrictive.
        </p>

        <h3>2.2.2 Fixed-Point Theories (Kripke)</h3>
        <p>
            Saul Kripke developed an alternative approach using fixed-point techniques from mathematical logic:
        </p>
        <ul style="font-size: 18px;">
            <li>Truth values are assigned in stages, starting with non-problematic (grounded) statements</li>
            <li>At each stage, more statements receive truth values based on the values assigned in previous stages</li>
            <li>Some statements, including the liar sentence, never receive a definite truth value they remain
                "undefined" or "ungrounded"</li>
            <li>The process reaches a "fixed point" where no more truth values can be consistently assigned</li>
        </ul>
        <p>
            In Kripke's framework, the liar sentence is neither true nor false but falls into a "truth-value gap." This
            avoids contradiction while allowing a limited form of self-reference.
        </p>
        <p>
            <strong>Limitations:</strong> While more permissive than Tarski's approach, Kripke's solution still
            restricts the expressiveness of the language by introducing a third "undefined" status for certain
            statements. It also struggles with "strengthened" versions of the liar paradox, such as "This statement is
            either false or undefined," which cannot be consistently classified within the system. The approach also
            lacks a natural linguistic interpretation, as ordinary speakers do not typically think in terms of
            "ungrounded" statements.
        </p>
        <p>
            Both approaches demonstrate a common theme: they resolve the paradox by restricting either the language's
            expressiveness or its adherence to classical logic. Our approach will take a different path by
            reconceptualizing the nature of truth evaluation itself.
        </p>

        <div class="key-takeaways">
            <h3>Key Takeaways: The Liar Paradox and Traditional Approaches</h3>
            <ul style="font-size: 18px;">

                <li>The liar paradox creates a contradiction through self-reference: <span class="math">œÑ(L) =
                        ¬¨œÑ(L)</span></li>
                <li>Tarski's solution restricts self-reference through a hierarchy of languages, but sacrifices natural
                    language expressiveness</li>
                <li>Kripke's fixed-point approach introduces truth-value gaps, but struggles with strengthened versions
                    of the paradox</li>
                <li>Both traditional approaches restrict expressiveness or abandon classical logic to avoid
                    contradiction</li>
                <li>Our category-theoretic approach will preserve both expressiveness and local classical logic by
                    treating truth as perspective-dependent</li>
            </ul>
        </div>

        <h3>2.2.3 Meta-Theoretical Consistency:</h3>

        <p>The meta-theoretical framework employed to
            develop and analyze subjective numbers is consistent if ZFC set theory is consistent.
        </p>



        <p>
            Our meta-theoretical framework is formulated entirely within ZFC set theory,
            using standard constructs such as sets, functions, relations, categories, and morphisms. We do not
            introduce any axioms or inference rules beyond those available in ZFC.
        </p>

        <p>
            If we assume ZFC is consistent (which is a standard assumption in mathematics), and since our framework
            is constructed entirely within ZFC, no inconsistency can arise in our meta-theoretical framework unless
            it was already present in ZFC itself.
        </p>

        <p>
            Moreover, our analysis of paradoxes like the liar paradox occurs within the object-level system of
            subjective numbers, not within the meta-theoretical framework itself. Any potential contradictions
            arising from self-reference are contained within the object-level system, which we show resolves these
            contradictions through perspective-dependent evaluation.
        </p>

        <p>
            Therefore, our meta-theoretical framework inherits the consistency of ZFC set theory and is not
            vulnerable to the paradoxes it is designed to address.
        </p>


        <p>
            The meta-theoretical stance we adopt is the standard one in mathematical practice: we reason
            about mathematical objects from outside the system those objects inhabit.
        </p>

        <p>
            This explicit addressing of meta-theoretical concerns demonstrates that our framework does not merely shift
            the paradox to a different level but provides a genuine resolution that is firmly grounded in standard
            mathematical practice.
        </p>

        <h3>2.2.4 Metatheoretical Principle of Static Continuity</h3>
        <div class="math-block">
            <strong>Metatheoretical Principle (Static Continuity):</strong>
            Unless otherwise specified, we assume that once an operation on fixed perspectives
            produces a given result at one time, it must produce the same result at any other time.
        </div>
        <p>
            Formal expression:
            <span class="math">
                ‚àÄp, q, r ‚àà <span class="math-set">P</span>, ‚àÄa, b, c ‚àà <span class="math-set">V</span>, ‚àÄœÜ ‚àà Operations:
                (a<sub>(p)</sub> œÜ<sub>p</sub> b<sub>(q)</sub> = c<sub>(r)</sub> at time t<sub>1</sub>)
                ‚Üí (a<sub>(p)</sub> œÜ<sub>p</sub> b<sub>(q)</sub> = c<sub>(r)</sub> at time t<sub>2</sub>).
            </span>
        </p>
        <p>
            <strong>Motivation:</strong> This principle does not forbid the introduction of time. Rather,
            it specifies that if time is to be part of the framework, it must be introduced
            <em>explicitly</em>. It establishes a baseline of stability for operations in the subjective numbers
            framework, ensuring predictability and mathematical coherence in the absence of explicitly time-dependent
            elements. This principle allows us to initially focus on the core innovation of perspective-dependence,
            setting a foundation for controlled extensions into dynamic systems in future work.
        </p>
        <!-- =================== CATEGORY THEORY FOUNDATIONS =================== -->
        <h2>3. Foundations for the Subjective Numbers Framework</h2>

        <h3>3.1 Category Theory Essentials</h3>
        <p>
            Before proceeding to our resolution of the liar paradox, we establish the category-theoretic foundations
            that will support our framework. Category theory provides the mathematical structure to formalize
            perspective-dependent truth and self-reference in a rigorous manner.
        </p>

        <div class="definition-box">
            <h3>Definition 3.1.1 (Category)</h3>
            <p>A <strong>category</strong> <span class="math">ùíû</span> consists of:</p>
            <ol style="font-size: 18px;">
                <li>A collection of <strong>objects</strong>, denoted by Ob(<span class="math">ùíû</span>)</li>
                <li>For each pair of objects <span class="math">A, B ‚àà Ob(ùíû)</span>, a set <span
                        class="math">Mor<sub>ùíû</sub>(A,
                        B)</span> of <strong>morphisms</strong> from <span class="math">A</span> to <span
                        class="math">B</span>. If <span class="math">f ‚àà
                        Mor<sub>ùíû</sub>(A, B)</span>, we write <span class="math">f: A ‚Üí B</span>.</li>
                <li>A <strong>composition operation</strong> that assigns to each pair of morphisms <span
                        class="math">f: A ‚Üí B</span> and <span class="math">g: B ‚Üí C</span> a morphism <span
                        class="math">g ‚àò f: A ‚Üí C</span>.</li>
                <li>For each object <span class="math">A ‚àà Ob(ùíû)</span>, an <strong>identity
                        morphism</strong> <span class="math">id<sub>A</sub>: A ‚Üí A</span>.</li>
            </ol>
            <p>The morphisms and composition must satisfy the following axioms:</p>
            <ul style="font-size: 18px;">
                <li><strong>Associativity:</strong> For morphisms <span class="math">f: A ‚Üí B</span>, <span
                        class="math">g: B ‚Üí C</span>, and <span class="math">h: C ‚Üí D</span>, we have <span
                        class="math">h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f</span>.</li>
                <li><strong>Identity:</strong> For any morphism <span class="math">f: A ‚Üí B</span>, <span class="math">f
                        ‚àò id<sub>A</sub> = f</span> and <span class="math">id<sub>B</sub> ‚àò f =
                        f</span>.</li>
            </ul>
        </div>

        <p>
            Intuitively, objects can be thought of as mathematical structures (sets, algebraic structures, topological
            spaces, etc.), and morphisms as structure-preserving maps between them. Composition represents the
            sequential application of such maps.
        </p>

        <div class="example-box">
            <h3>Example 3.1.1: A Simple Category</h3>
            <p>Consider a category with two objects <span class="math">P<sub>1</sub></span> and <span
                    class="math">P<sub>2</sub></span>,
                representing two different perspectives. The morphisms in this category include:</p>
            <ul style="font-size: 18px;">
                <li>Identity morphisms: <span class="math">id<sub>P<sub>1</sub></sub>: P<sub>1</sub> ‚Üí
                        P<sub>1</sub></span> and <span class="math">id<sub>P<sub>2</sub></sub>:
                        P<sub>2</sub> ‚Üí P<sub>2</sub></span></li>
                <li>Perspective transition morphisms: <span class="math">f: P<sub>1</sub> ‚Üí P<sub>2</sub></span> and
                    <span class="math">g:
                        P<sub>2</sub> ‚Üí P<sub>1</sub></span>
                </li>
            </ul>
            <p>Composition gives us <span class="math">g ‚àò f: P<sub>1</sub> ‚Üí P<sub>1</sub></span> and <span
                    class="math">f ‚àò g:
                    P<sub>2</sub> ‚Üí P<sub>2</sub></span>. These composite morphisms represent how truth evaluations
                change when
                transitioning from one perspective to another and back.</p>
        </div>

        <div class="definition-box">
            <h3>Definition 3.1.2 (Quotient Category)</h3>
            <p>A <strong>quotient category</strong> is formed by identifying certain morphisms as "equivalent" according
                to an equivalence relation <span class="math">‚â°</span>. For the quotient construction to yield a
                well-defined category, this equivalence relation must satisfy:</p>
            <ol style="font-size: 18px;">
                <li>If <span class="math">f ‚â° g</span>, then <span class="math">f</span> and <span class="math">g</span>
                    must have the same source and target objects.</li>
                <li>If <span class="math">f<sub>1</sub> ‚â° f<sub>2</sub></span> and <span class="math">g<sub>1</sub> ‚â°
                        g<sub>2</sub></span>, and the
                    compositions <span class="math">g<sub>1</sub> ‚àò f<sub>1</sub></span> and <span
                        class="math">g<sub>2</sub> ‚àò f<sub>2</sub></span> are
                    defined, then <span class="math">g<sub>1</sub> ‚àò f<sub>1</sub> ‚â° g<sub>2</sub> ‚àò
                        f<sub>2</sub></span>.</li>
                <li>Identity morphisms are equivalent only to themselves.</li>
            </ol>
            </p>

            <p>
                Quotient categories are particularly useful when we want to identify morphisms that behave "the same
                way" for our purposes, even if they are not identical. In our framework, we will use a quotient category
                to identify morphisms with equivalent behavior in truth evaluation.
            </p>
        </div>

        <h3>3.2 Core Concepts and Definitions</h3>

        <div class="definition-box">
            <h3>Definition 3.2.1 (Subjective Number)</h3>
            <p>A <strong>subjective number</strong> is a pair <span class="math">a<sub>(p)</sub></span> where <span
                    class="math">a ‚àà <span class="math-set">V</span></span> is a truth value and <span class="math">p ‚àà
                    <span class="math-set">P</span></span>
                is a perspective. It represents the value <span class="math">a</span> as evaluated from perspective
                <span class="math">p</span>.
            </p>
        </div>

        <h3>3.2.2 Value Space (V)</h3>
        <p>
            We define <span class="math-set">V</span> as a Boolean algebra a specific type of algebraic structure with
            well-defined operations for conjunction, disjunction, and negation. For clarity, we will use the familiar
            set <span class="math">{true, false}</span> with its standard operations, though the framework extends to
            more general Boolean algebras.
        </p>
        <p>
            Formally, <span class="math-set">V</span> is equipped with:
        </p>
        <ul style="font-size: 18px;">
            <li>Binary operations <span class="math">‚àß</span> (conjunction) and <span class="math">‚à®</span>
                (disjunction)</li>
            <li>A unary operation <span class="math">¬¨</span> (negation)</li>
            <li>Distinguished elements <span class="math">true<sub>0</sub></span> (top element/identity for conjunction)
                and <span class="math">false<sub>0</sub></span> (bottom element/identity for disjunction)</li>
        </ul>
        <p>
            These operations satisfy the standard axioms of Boolean algebra, including associativity, commutativity,
            distributivity, identity laws, and complementation. The distinguished element <span
                class="math">true<sub>0</sub></span>
            serves as the identity element for logical operations and corresponds to the standard <span
                class="math">true</span>
            truth value in the Boolean algebra, while <span class="math">false<sub>0</sub></span> similarly corresponds
            to
            the standard <span class="math">false</span>.
        </p>

        <h3>3.2.3 Perspectives (P)</h3>
        <p>
            Let <span class="math-set">P</span> be a non-empty set whose elements represent distinct perspectives or
            viewpoints. A perspective serves as the "world" from which truth evaluations are made. These perspectives
            are not mere labels but fundamental mathematical objects in our framework.
        </p>
        <p>
            Each perspective <span class="math">p ‚àà <span class="math-set">P</span></span> has its own standard for
            evaluation, and these standards may differ across perspectives. This is a crucial departure from traditional
            logic, where truth evaluation is assumed to be universal and perspective-independent.
        </p>

        <div class="example-box">
            <h3>Example 3.2.1: Basic Subjective Numbers</h3>
            <p>Consider two perspectives <span class="math">P<sub>1</sub></span> and <span
                    class="math">P<sub>2</sub></span>, and the
                standard Boolean values <span class="math">true</span> and <span class="math">false</span>. We can form
                the following subjective numbers:</p>
            <ul style="font-size: 18px;">
                <li><span class="math">true<sub>(P<sub>1</sub>)</sub></span>: The value "true" as evaluated from
                    perspective <span class="math">P<sub>1</sub></span></li>
                <li><span class="math">false<sub>(P<sub>1</sub>)</sub></span>: The value "false" as evaluated from
                    perspective <span class="math">P<sub>1</sub></span></li>
                <li><span class="math">true<sub>(P<sub>2</sub>)</sub></span>: The value "true" as evaluated from
                    perspective <span class="math">P<sub>2</sub></span></li>
                <li><span class="math">false<sub>(P<sub>2</sub>)</sub></span>: The value "false" as evaluated from
                    perspective <span class="math">P<sub>2</sub></span></li>
            </ul>
            <p>These subjective numbers can have different relations to each other. For instance, perspective <span
                    class="math">P<sub>1</sub></span> might consider <span
                    class="math">true<sub>(P<sub>1</sub>)</sub></span> equal to <span
                    class="math">true<sub>(P<sub>2</sub>)</sub></span>, while perspective <span
                    class="math">P<sub>2</sub></span> might not
                reciprocate this equality.</p>
        </div>

        <h3>3.2.4 Subjective Numbers as Morphisms</h3>
        <p>
            Rather than merely labeling statements with perspectives, we represent them as morphisms that capture both
            the truth value and the transition between perspectives. For any two perspectives <span class="math">p, q
                ‚àà <span class="math-set">P</span></span> and any value <span class="math">a ‚àà <span
                    class="math-set">V</span></span>, we define a morphism:
        </p>
        <div class="math-block">
            <span class="math">f<sub>(a, p ‚Üí q)</sub> : p ‚Üí q</span>
        </div>
        <p>
            Intuitively, this morphism represents the evaluation of the truth value <span class="math">a</span> when
            transitioning from perspective <span class="math">p</span> to perspective <span class="math">q</span>. The
            morphism encapsulates not just the static truth value, but the dynamic process of evaluation from one
            perspective to another.
        </p>
        <p>
            For a statement like the liar paradox, we can define morphisms that represent both the statement itself and
            the process of evaluating its truth. This dynamic view of truth evaluation is essential for handling
            self-reference.
        </p>

        <h3>3.3 Subjective Equality and Truth Relations</h3>
        <p>
            We introduce a family of relation functions:
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub> : <span class="math-set">P</span> √ó <span class="math-set">P</span> √ó <span
                    class="math-set">V</span> √ó <span class="math-set">V</span> ‚Üí {
                true, false }</span>
        </div>
        <p>
            where for any perspectives <span class="math">s, t ‚àà <span class="math-set">P</span></span> and values
            <span class="math">a, b ‚àà <span class="math-set">V</span></span>, the statement
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(s,t,a,b) = true</span>
        </div>
        <p>
            indicates that, from the viewpoint of perspective <span class="math">p</span>, the subjective number <span
                class="math">a<sub>(s)</sub></span> is considered "equal in truth" to <span
                class="math">b<sub>(t)</sub></span>. Using
            our notation for subjective equality, we can write:
        </p>
        <div class="math-block">
            <span class="math">a<sub>(s)</sub> =<sub>p</sub> b<sub>(t)</sub> ‚ü∫ R<sub>p</sub>(s,t,a,b) = true</span>
        </div>
        <p>
            Note that this relation is not an equality of morphisms but an evaluation how perspective <span
                class="math">p</span> "interprets" the composite of morphisms. This distinction is crucial, as it allows
            for perspective-dependent evaluations that may differ across different viewpoints.
        </p>

        <div class="definition-box">
            <h3>Definition 3.3.1 (Well-Formed Relation Function)</h3>
            <p>A relation function <span class="math">R<sub>p</sub></span> is considered well-formed if it satisfies:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Internal Consistency:</strong> If <span class="math">R<sub>p</sub>(s, t, a, b) = true</span>
                    and <span class="math">R<sub>p</sub>(t, u, b, c) = true</span>, then <span
                        class="math">R<sub>p</sub>(s, u, a, c)
                        = true</span> (transitivity within perspective <span class="math">p</span>)</li>
                <li><strong>Self-Reflexivity:</strong> For all <span class="math">a ‚àà <span
                            class="math-set">V</span></span>, <span class="math">R<sub>p</sub>(p, p, a, a) = true</span>
                    (a perspective considers a value equal to
                    itself)</li>
                <li><strong>Value Invariance:</strong> If <span class="math">a = c</span> in <span
                        class="math-set">V</span>, then <span class="math">R<sub>p</sub>(s, t, a, b) = R<sub>p</sub>(s,
                        t, c, b)</span>;
                    similarly, if <span class="math">b = d</span> in <span class="math-set">V</span>, then <span
                        class="math">R<sub>p</sub>(s, t, a, b) = R<sub>p</sub>(s, t, a, d)</span> (numerical equality
                    implies relation
                    equality)</li>
            </ol>
        </div>

        <h3>3.3.2 Cross-Perspective Adoption Function</h3>
        <p>
            A central concept in our framework is the cross-perspective adoption function, which formalizes when and how
            one perspective may accept evaluations made by another:
        </p>
        <div class="math-block">
            <span class="math">CPA<sub>p</sub>: <span class="math-set">P</span> √ó <span class="math-set">P</span> ‚Üí
                {true, false}</span>
        </div>
        <p>
            where <span class="math">CPA<sub>p</sub>(q, r) = true</span> means that perspective <span
                class="math">p</span>
            accepts evaluations made by perspective <span class="math">q</span> regarding perspective <span
                class="math">r</span>.
        </p>
        <p>
            This function represents a form of "trust" or "acceptance" between perspectives. When <span
                class="math">CPA<sub>p</sub>(q, r) = true</span>, perspective <span class="math">p</span> is willing to
            incorporate <span class="math">q</span>'s judgments about <span class="math">r</span> into its own
            reasoning. This provides precise control over which chains of inference are allowed to cross perspective
            boundaries.
        </p>

        <div class="example-box">
            <h3>Example 3.3.1: Cross-Perspective Evaluation</h3>
            <p>Continuing with our perspectives <span class="math">P<sub>1</sub></span> and <span
                    class="math">P<sub>2</sub></span>, let's
                define:</p>
            <ul style="font-size: 18px;">
                <li><span class="math">R<sub>P<sub>1</sub></sub>(P<sub>1</sub>, P<sub>2</sub>, true, true) = true</span>
                    (from <span class="math">P<sub>1</sub></span>'s
                    perspective, its "true" equals <span class="math">P<sub>2</sub></span>'s "true")
                </li>
                <li><span class="math">R<sub>P<sub>2</sub></sub>(P<sub>2</sub>, P<sub>1</sub>, true, false) =
                        true</span> (from <span class="math">P<sub>2</sub></span>'s perspective, its "true" equals <span
                        class="math">P<sub>1</sub></span>'s
                    "false")</li>
                <li><span class="math">CPA<sub>P<sub>1</sub></sub>(P<sub>2</sub>, P<sub>1</sub>) = true</span> (<span
                        class="math">P<sub>1</sub></span> accepts
                    <span class="math">P<sub>2</sub></span>'s evaluations about <span class="math">P<sub>1</sub></span>)
                </li>
            </ul>
            <p>Then, through cross-perspective adoption, <span class="math">P<sub>1</sub></span> would accept that <span
                    class="math">true<sub>(P<sub>2</sub>)</sub> =<sub>P<sub>1</sub></sub>
                    false<sub>(P<sub>1</sub>)</sub></span>, even though it initially evaluated <span
                    class="math">true<sub>(P<sub>1</sub>)</sub> =<sub>P<sub>1</sub></sub>
                    true<sub>(P<sub>2</sub>)</sub></span>.</p>
        </div>

        <h3>3.4 The Category ùì¢ùìù (Subjective Numbers)</h3>
        <p>
            We now define our category <span class="math">ùì¢ùìù</span> (Subjective Numbers):
        </p>

        <h3>3.4.1 Objects</h3>
        <p>
            The objects of <span class="math">ùì¢ùìù</span> are the perspectives <span class="math">p ‚àà <span
                    class="math-set">P</span></span>.
        </p>

        <h3>3.4.2 Morphisms</h3>
        <p>
            For any two perspectives <span class="math">p, q ‚àà <span class="math-set">P</span></span> and any value
            <span class="math">a ‚àà <span class="math-set">V</span></span>, there is a morphism:
        </p>
        <div class="math-block">
            <span class="math">f<sub>(a, p ‚Üí q)</sub> : p ‚Üí q</span>
        </div>
        <p>
            The set of all morphisms from <span class="math">p</span> to <span class="math">q</span> is denoted:
        </p>
        <div class="math-block">
            <span class="math">Mor<sub>ùì¢ùìù</sub>(p, q) = {f<sub>(a, p ‚Üí q)</sub> | a ‚àà <span
                    class="math-set">V</span>}</span>
        </div>
        <p>
            These morphisms represent truth evaluations with perspective transitions.
        </p>

        <h3>3.4.3 Composition</h3>
        <p>
            For morphisms
        </p>
        <div class="math-block">
            <span class="math">f<sub class="math-subscript">(a, p <span class="math-op">‚Üí</span> q)</sub></span> <span
                class="math-op">:</span> <span class="math">p</span> <span class="math-op">‚Üí</span> <span
                class="math">q</span>
            <span class="math-op">and</span>
            <span class="math">g<sub class="math-subscript">(b, q <span class="math-op">‚Üí</span> r)</sub></span> <span
                class="math-op">:</span> <span class="math">q</span> <span class="math-op">‚Üí</span> <span
                class="math">r</span>
        </div>
        <p>
            we define their composition as:
        </p>
        <div class="math-block">
            <span class="math">g<sub>(b, q ‚Üí r)</sub> ‚àò f<sub>(a, p ‚Üí q)</sub> = f<sub>((a,b), p ‚Üí r)</sub></span>
        </div>
        <p>
            In this composition, we follow the standard categorical notation where <span class="math">g ‚àò f</span>
            denotes "g after f", meaning first apply <span class="math">f</span> followed by <span
                class="math">g</span>. The new morphism <span class="math">f<sub>((a,b), p ‚Üí r)</sub></span>
            records the "history" of evaluations starting with truth value <span class="math">a</span> in perspective
            <span class="math">p</span> and transitioning via <span class="math">b</span> from <span
                class="math">q</span>. This approach:
        </p>
        <ul style="font-size: 18px;">
            <li>Records both the original value and intermediate value, creating a richer structure that captures the
                path of perspective transitions</li>
            <li>Makes morphisms "path-aware," which is crucial for modeling domains where evaluation history matters
            </li>
            <li>Forms a quotient category structure through explicit equivalence relations to satisfy categorical axioms
            </li>
        </ul>

        <h3>3.4.4 Identity</h3>
        <p>
            For each perspective <span class="math">p</span>, the identity morphism is defined as:
        </p>
        <div class="math-block">
            <span class="math">id<sub>p</sub> = f<sub>(true<sub>0</sub>, p ‚Üí p)</sub></span>
        </div>
        <p>
            where <span class="math">true<sub>0</sub></span> is the identity element in <span class="math-set">V</span>
            for the relevant logical operations. This choice ensures that when we later define operations in Section 6,
            the identity morphism composes appropriately with other morphisms while preserving the logical semantics:
            if <span class="math">f<sub>(a, p ‚Üí q)</sub></span> represents a subjective number with value <span
                class="math">a</span>,
            then <span class="math">f<sub>(a, p ‚Üí q)</sub> ‚àò id<sub>p</sub> = f<sub>(a, p ‚Üí q)</sub></span> both as a
            morphism
            and in terms of the represented value <span class="math">a</span>.
        </p>

        <h3>3.4.5 Quotient Category Construction and Well-Definedness</h3>
        <p>
            The composition defined above must satisfy associativity and identity laws to form a proper category. To
            ensure this, we introduce an equivalence relation (denoted by <span class="math">‚â°</span>) on the set
            of morphisms. We will now rigorously demonstrate that this equivalence relation is well-defined and
            compatible with the categorical
            structure.
        </p>

        <p>
            <strong>Definition 3.4.1 (Morphism Equivalence Relation):</strong> Two morphisms
        </p>
        <div class="math-block">
            <span class="math">f<sub class="math-subscript">(h<sub class="math-subscript">1</sub>, p <span
                        class="math-op">‚Üí</span> q)</sub></span>
            <span class="math-op">and</span>
            <span class="math">f<sub class="math-subscript">(h<sub class="math-subscript">2</sub>, p <span
                        class="math-op">‚Üí</span> q)</sub></span>
        </div>
        <p>
            are declared equivalent (written <span class="math">f<sub class="math-subscript">(h<sub
                        class="math-subscript">1</sub>, p <span class="math-op">‚Üí</span> q)</sub></span> <span
                class="math">‚â°</span>
            <span class="math">f<sub class="math-subscript">(h<sub class="math-subscript">2</sub>, p <span
                        class="math-op">‚Üí</span> q)</sub></span></span>)
            if and only if:
        </p>
        <ol style="font-size: 18px;">
            <li>They have the same source and target objects (i.e., the same <span class="math">p</span> and <span
                    class="math">q</span>), and</li>
            <li>Their value histories <span class="math">h<sub class="math-subscript">1</sub></span> and <span
                    class="math">h<sub class="math-subscript">2</sub></span> are equivalent
                under an equivalence relation <span class="math">‚àº</span> on value histories.</li>
        </ol>

        <p>
            <strong>Definition 3.4.2 (Value History Equivalence Relation):</strong> We define the equivalence relation
            <span class="math">‚àº</span> on value histories as the smallest equivalence relation satisfying the following
            conditions:
        </p>

        <ol style="font-size: 18px;">
            <li><strong>Identity Properties:</strong>
                <ul style="font-size: 18px;">
                    <li>For any value <span class="math">a ‚àà <span class="math-set">V</span></span>, <span
                            class="math">(true<sub>0</sub>, a) ‚àº a</span> and <span class="math">(a, true<sub>0</sub>) ‚àº
                            a</span>, where <span class="math">true<sub>0</sub></span> is the identity element
                        for the relevant logical operation in <span class="math-set">V</span>.</li>
                </ul>
            </li>
            <li><strong>Associativity:</strong> For any values <span class="math">a, b, c ‚àà <span
                        class="math-set">V</span></span>, <span class="math">((a, b), c) ‚àº (a, (b, c))</span>.</li>
            <li><strong>Closure Properties:</strong> The relation <span class="math">‚àº</span> is closed under:
                <ul style="font-size: 18px;">
                    <li><strong>Reflexivity:</strong> For all value histories <span class="math">h</span>, <span
                            class="math">h ‚àº h</span>.</li>
                    <li><strong>Symmetry:</strong> If <span class="math">h<sub>1</sub> ‚àº h<sub>2</sub></span>, then
                        <span class="math">h<sub>2</sub> ‚àº h<sub>1</sub></span>.
                    </li>
                    <li><strong>Transitivity:</strong> If <span class="math">h<sub>1</sub> ‚àº h<sub>2</sub></span> and
                        <span class="math">h<sub>2</sub> ‚àº h<sub>3</sub></span>, then <span class="math">h<sub>1</sub> ‚àº
                            h<sub>3</sub></span>.
                    </li>
                </ul>
            </li>
        </ol>

        <p>
            <strong>Definition 3.4.3 (Formal Construction of Value History Equivalence):</strong> More precisely, we can
            construct the equivalence relation <span class="math">‚àº</span> as follows:
        </p>

        <ol style="font-size: 18px;">
            <li>Define the base relation <span class="math">‚àº<sub>0</sub></span> containing exactly the pairs:
                <ul style="font-size: 18px;">
                    <li><span class="math">(true<sub>0</sub>, a) ‚àº<sub>0</sub> a</span> and <span class="math">(a,
                            true<sub>0</sub>) ‚àº<sub>0</sub>
                            a</span> for all <span class="math">a ‚àà <span class="math-set">V</span></span></li>
                    <li><span class="math">((a, b), c) ‚àº<sub>0</sub> (a, (b, c))</span> for all <span class="math">a, b,
                            c ‚àà <span class="math-set">V</span></span></li>
                </ul>
            </li>
            <li>Create the reflexive closure by adding <span class="math">h ‚àº<sub>1</sub> h</span> for all value
                histories <span class="math">h</span>.</li>
            <li>Create the symmetric closure by adding <span class="math">h<sub>2</sub> ‚àº<sub>2</sub>
                    h<sub>1</sub></span> whenever <span class="math">h<sub>1</sub> ‚àº<sub>1</sub> h<sub>2</sub></span>.
            </li>
            <li>Create the transitive closure by adding <span class="math">h<sub>1</sub> ‚àº<sub>3</sub>
                    h<sub>3</sub></span> whenever <span class="math">h<sub>1</sub> ‚àº<sub>2</sub> h<sub>2</sub></span>
                and <span class="math">h<sub>2</sub> ‚àº<sub>2</sub> h<sub>3</sub></span>.</li>
            <li>Define the final equivalence relation <span class="math">‚àº</span> as <span
                    class="math">‚àº<sub>3</sub></span>.</li>
        </ol>

        <p>
            <strong>Proposition 3.4.1:</strong> The equivalence relation <span class="math">‚â°</span> on morphisms
            satisfies the requirements for a quotient category:
        </p>

        <ol style="font-size: 18px;">
            <li>If <span class="math">f ‚â° g</span>, then <span class="math">f</span> and <span class="math">g</span>
                have the same source and target objects (by definition).</li>
            <li>If <span class="math">f<sub>1</sub> ‚â° f<sub>2</sub></span> and <span class="math">g<sub>1</sub> ‚â°
                    g<sub>2</sub></span>, and if <span class="math">g<sub>1</sub> ‚àò f<sub>1</sub></span> and <span
                    class="math">g<sub>2</sub> ‚àò f<sub>2</sub></span> are defined, then <span class="math">g<sub>1</sub>
                    ‚àò f<sub>1</sub> ‚â° g<sub>2</sub> ‚àò f<sub>2</sub></span>.</li>
            <li>Identity morphisms are equivalent only to themselves.</li>
        </ol>

        <p>
            This equivalence relation ensures that the categorical axioms of associativity and identity are satisfied in
            our quotient category. For instance, it guarantees that:
        </p>
        <ul style="font-size: 18px;">
            <li><span class="math">f<sub>(a, p‚Üíq)</sub> ‚àò id<sub>p</sub> ‚â° f<sub>(a, p‚Üíq)</sub></span></li>
            <li><span class="math">id<sub>q</sub> ‚àò f<sub>(a, p‚Üíq)</sub> ‚â° f<sub>(a, p‚Üíq)</sub></span></li>
            <li><span class="math">(f<sub>(c, r‚Üís)</sub> ‚àò f<sub>(b, q‚Üír)</sub>) ‚àò f<sub>(a, p‚Üíq)</sub> ‚â° f<sub>(c,
                        r‚Üís)</sub>
                    ‚àò (f<sub>(b, q‚Üír)</sub> ‚àò f<sub>(a, p‚Üíq)</sub>)</span></li>
        </ul>

        <p>
            This construction yields morphism equivalence classes that behave appropriately under composition. When we
            work with the category <span class="math">ùì¢ùìù</span>, we are actually working with these
            equivalence classes rather than with the individual morphisms themselves. This abstraction enables us to
            focus on the essential structure of perspective transitions without being distracted by irrelevant
            distinctions in representation.
        </p>

        <div class="theorem">
            <strong>Theorem 3.1 (Well-Definedness of ùì¢ùìù):</strong> The construction of <span class="math">ùì¢ùìù</span>
            as a quotient category yields a well-defined category that satisfies
            all categorical axioms.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> We need to verify that our quotient construction preserves the essential
                category laws:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Identity Laws:</strong> For any morphism <span class="math">f<sub>(a, p ‚Üí q)</sub></span>,
                    we need
                    to show:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(a, p‚Üíq)</sub> ‚àò id<sub>p</sub> ‚â° f<sub>(a, p‚Üíq)</sub></span></li>
                        <li><span class="math">id<sub>q</sub> ‚àò f<sub>(a, p‚Üíq)</sub> ‚â° f<sub>(a, p‚Üíq)</sub></span></li>
                    </ul>
                    By definition:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(a, p‚Üíq)</sub> ‚àò id<sub>p</sub> = f<sub>(a, p‚Üíq)</sub> ‚àò
                                f<sub>(true<sub>0</sub>, p ‚Üí p)</sub>
                                = f<sub>((true<sub>0</sub>, a), p ‚Üí q)</sub></span></li>
                        <li>Using our equivalence relation: <span class="math">f<sub>((true<sub>0</sub>, a), p ‚Üí
                                    q)</sub> ‚â° f<sub>(a,
                                    p ‚Üí q)</sub></span> since <span class="math">(true<sub>0</sub>, a) ‚àº a</span></li>
                    </ul>
                    Similarly, <span class="math">id<sub>q</sub> ‚àò f<sub>(a, p‚Üíq)</sub> = f<sub>((a, true<sub>0</sub>),
                            p ‚Üí q)</sub> ‚â° f<sub>(a,
                            p ‚Üí q)</sub></span> since <span class="math">(a, true<sub>0</sub>) ‚àº a</span>.
                </li>
                <li><strong>Associativity:</strong> For morphisms <span class="math">f<sub>(a, p‚Üíq)</sub></span>, <span
                        class="math">f<sub>(b, q‚Üír)</sub></span>, and <span class="math">f<sub>(c, r‚Üís)</sub></span>, we
                    need to
                    show:
                    <ul style="font-size: 18px;">
                        <li><span class="math">(f<sub>(c, r‚Üís)</sub> ‚àò f<sub>(b, q‚Üír)</sub>) ‚àò f<sub>(a, p‚Üíq)</sub> ‚â°
                                f<sub>(c, r‚Üís)</sub> ‚àò (f<sub>(b, q‚Üír)</sub> ‚àò f<sub>(a, p‚Üíq)</sub>)</span></li>
                    </ul>
                    Computing the left-hand side:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(b, q‚Üír)</sub> ‚àò f<sub>(a, p‚Üíq)</sub> = f<sub>((a,b), p ‚Üí
                                    r)</sub></span></li>
                        <li><span class="math">(f<sub>(c, r‚Üís)</sub> ‚àò f<sub>(b, q‚Üír)</sub>) ‚àò f<sub>(a, p‚Üíq)</sub> =
                                f<sub>(c,
                                    r‚Üís)</sub> ‚àò f<sub>((a,b), p ‚Üí r)</sub> = f<sub>(((a,b),c), p ‚Üí s)</sub></span></li>
                    </ul>
                    Computing the right-hand side:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(c, r‚Üís)</sub> ‚àò f<sub>(b, q‚Üír)</sub> = f<sub>((b,c), q ‚Üí
                                    s)</sub></span></li>
                        <li><span class="math">f<sub>(c, r‚Üís)</sub> ‚àò (f<sub>(b, q‚Üír)</sub> ‚àò f<sub>(a, p‚Üíq)</sub>) =
                                f<sub>((b,c), q ‚Üí s)</sub> ‚àò f<sub>(a, p‚Üíq)</sub> = f<sub>((a,(b,c)), p ‚Üí
                                    s)</sub></span></li>
                    </ul>
                    By our defined equivalence relation, <span class="math">((a,b),c) ‚àº (a,(b,c))</span>, so:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(((a,b),c), p ‚Üí s)</sub> ‚â° f<sub>((a,(b,c)), p ‚Üí s)</sub></span>
                        </li>
                    </ul>
                    This confirms that associativity holds in our quotient category.
                </li>
                <li><strong>Compatibility of Composition:</strong> We also need to verify that composition is
                    well-defined on equivalence classes. If <span class="math">f<sub>(h<sub>1</sub>, p‚Üíq)</sub> ‚â°
                        f<sub>(h<sub>2</sub>, p‚Üí
                            q)</sub></span> and <span class="math">f<sub>(k<sub>1</sub>, q‚Üír)</sub> ‚â°
                        f<sub>(k<sub>2</sub>, q‚Üír)</sub></span>, then we
                    must have:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(k<sub>1</sub>, q‚Üír)</sub> ‚àò f<sub>(h<sub>1</sub>, p‚Üíq)</sub> ‚â°
                                f<sub>(k<sub>2</sub>, q‚Üír)</sub> ‚àò
                                f<sub>(h<sub>2</sub>, p‚Üíq)</sub></span></li>
                    </ul>
                    Since <span class="math">h<sub>1</sub> ‚àº h<sub>2</sub></span> and <span class="math">k<sub>1</sub> ‚àº
                        k<sub>2</sub></span>, we have:
                    <ul style="font-size: 18px;">
                        <li><span class="math">f<sub>(k<sub>1</sub>, q‚Üír)</sub> ‚àò f<sub>(h<sub>1</sub>, p‚Üíq)</sub> =
                                f<sub>((h<sub>1</sub>,k<sub>1</sub>), p ‚Üí
                                    r)</sub></span></li>
                        <li><span class="math">f<sub>(k<sub>2</sub>, q‚Üír)</sub> ‚àò f<sub>(h<sub>2</sub>, p‚Üíq)</sub> =
                                f<sub>((h<sub>2</sub>,k<sub>2</sub>), p ‚Üí
                                    r)</sub></span></li>
                    </ul>
                    The value history equivalence relation <span class="math">‚àº</span> is defined to be compatible
                    with tupling, so <span class="math">(h<sub>1</sub>,k<sub>1</sub>) ‚àº
                        (h<sub>2</sub>,k<sub>2</sub>)</span>, ensuring that composition is
                    well-defined on equivalence classes.
                </li>
            </ol>
            <p>
                The above verifies that <span class="math">ùì¢ùìù</span>, with the morphism equivalences defined above,
                forms a well-defined category. ‚ñ°
            </p>
        </div>

        <h3>3.5 Axioms for Subjective Truth</h3>
        <p>
            Our framework is governed by the following axioms that connect the relation functions <span
                class="math">R<sub>p</sub></span> with the categorical structure:
        </p>

        <p>
            <strong>Axiom 3.5.1 (Subjective Reflexivity):</strong> For any perspective <span class="math">p ‚àà <span
                    class="math-set">P</span></span> and any value <span class="math">a ‚àà <span
                    class="math-set">V</span></span>,
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, p, a, a) = true</span>
        </div>
        <p>
            This reflects the idea that every subjective number is self-identical from its own perspective.
        </p>

        <p>
            <strong>Axiom 3.5.2 (Non-Symmetric Evaluation):</strong> It is not necessarily the case that if
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, q, a, b) = true</span>
        </div>
        <p>
            then
        </p>
        <div class="math-block">
            <span class="math">R<sub>q</sub>(q, p, b, a) = true</span>
        </div>
        <p>
            This asymmetry captures the fact that different perspectives may evaluate the same truth values differently.
        </p>

        <p>
            <strong>Axiom 3.5.3 (Subjective Transitivity within a Perspective):</strong> For any fixed perspective <span
                class="math">r</span>, if
        </p>
        <div class="math-block">
            <span class="math">R<sub>r</sub>(p, q, a, b) = true</span> <span class="math">and</span> <span
                class="math">R<sub>r</sub>(q, s, b, c) = true</span>
        </div>
        <p>
            then
        </p>
        <div class="math-block">
            <span class="math">R<sub>r</sub>(p, s, a, c) = true</span>
        </div>
        <p>
            Thus, within any one perspective, the evaluation of truth is transitive.
        </p>

        <p>
            <strong>Axiom 3.5.4 (Cross-Perspective Inference):</strong> Suppose
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, q, a, b) = true</span> <span class="math">and</span> <span
                class="math">R<sub>q</sub>(q, r, b, c) = true</span>
        </div>
        <p>
            Then, the inference
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, r, a, c) = true</span>
        </div>
        <p>
            holds if and only if a cross-perspective adoption function satisfies
        </p>
        <div class="math-block">
            <span class="math">CPA<sub>p</sub>(q, r) = true</span>
        </div>
        <p>
            This function, <span class="math">CPA<sub>p</sub>(q, r)</span>, explicitly governs when evaluations can
            "cross" from
            one perspective to another.
        </p>

        <p>
            <strong>Axiom 3.5.5 (Value Consistency):</strong> If
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, q, a, b) = true</span>
        </div>
        <p>
            and
        </p>
        <div class="math-block">
            <span class="math">a = c</span> in <span class="math-set">V</span>
        </div>
        <p>
            then
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, q, c, b) = true</span>
        </div>
        <p>
            Thus, the intrinsic algebraic structure of <span class="math-set">V</span> (i.e., its Boolean nature) is
            preserved.
        </p>

        <p>
            <strong>Axiom 3.5.6 (Perspective Adoption via Morphism Composition):</strong> Let <span
                class="math">f<sub>(a, p
                    ‚Üí q)</sub></span> be a morphism representing a subjective number. Then, for any perspective <span
                class="math">r</span>, composing with another morphism <span class="math">f<sub>(b, q ‚Üí r)</sub></span>
            yields
        </p>
        <div class="math-block">
            <span class="math">f<sub>(b, q ‚Üí r)</sub> ‚àò f<sub>(a, p ‚Üí q)</sub> = f<sub>((a,b), p ‚Üí r)</sub></span>
        </div>
        <p>
            which formalizes the idea that the evaluation from perspective <span class="math">r</span> is obtained by
            "adopting" the evaluation from <span class="math">q</span>. This axiom rigorously implements perspective
            adoption via composition.
        </p>

        <p>
            <strong>Axiom 3.5.7 (Perspective Distinctness):</strong> For any two distinct perspectives <span
                class="math">p
                ‚â† q</span>, there exists some pair <span class="math">a, b ‚àà <span class="math-set">V</span></span>
            such that
        </p>
        <div class="math-block">
            <span class="math">R<sub>p</sub>(p, q, a, b) ‚â† R<sub>q</sub>(q, p, b, a)</span>
        </div>
        <p>
            This guarantees that different perspectives are not trivially equivalent.
        </p>

        <h3>3.6 Connection Between Relation Functions and Morphisms</h3>
        <p>
            The relation functions <span class="math">R<sub>p</sub></span> and the morphisms in <span
                class="math">ùì¢ùìù</span> are
            linked by the following theorem:
        </p>

        <div class="theorem">
            <strong>Theorem 3.2 (Morphism-Relation Correspondence):</strong> For any perspectives <span class="math">p,
                q, r ‚àà <span class="math-set">P</span></span> and values <span class="math">a, b ‚àà <span
                    class="math-set">V</span></span>,
            <span class="math">R<sub>p</sub>(q, r, a, b) = true</span> if and only if <span class="math">f<sub>(a, q ‚Üí
                    p)</sub>
                ‚àò f<sub>(b, r ‚Üí p)</sub></span> is equivalent to the identity morphism <span
                class="math">id<sub>p</sub></span> in
            the quotient category <span class="math">ùì¢ùìù</span>.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Let us establish the correspondence in both directions.
            </p>
            <p>
                <strong>(‚áí) Assume <span class="math">R<sub>p</sub>(q, r, a, b) = true</span>:</strong>
            </p>
            <p>
                By the definition of our relation function <span class="math">R<sub>p</sub></span>, this means that from
                perspective <span class="math">p</span>, the subjective number <span class="math">a<sub>(q)</sub></span>
                is
                considered equal to <span class="math">b<sub>(r)</sub></span>. In terms of morphisms, we have:
            </p>
            <ul style="font-size: 18px;">
                <li><span class="math">f<sub>(a, q ‚Üí p)</sub></span> represents the subjective number <span
                        class="math">a<sub>(q)</sub></span> as evaluated from perspective <span class="math">p</span>
                </li>
                <li><span class="math">f<sub>(b, r ‚Üí p)</sub></span> represents the subjective number <span
                        class="math">b<sub>(r)</sub></span> as evaluated from perspective <span class="math">p</span>
                </li>
            </ul>
            <p>
                When these morphisms compose into the identity (under the quotient category's equivalence relation), it
                indicates that the evaluation produces no change in truth value from <span class="math">p</span>'s
                perspective. Thus:
            </p>
            <div class="math-block">
                <span class="math">f<sub>(a, q ‚Üí p)</sub> ‚àò f<sub>(b, r ‚Üí p)</sub> = f<sub>((b,a), r ‚Üí p)</sub> ‚â°
                    id<sub>p</sub> =
                    f<sub>(true<sub>0</sub>, p ‚Üí p)</sub></span>
            </div>
            <p>
                Note that the composition order above follows our definition in Section 3.4.3, where <span
                    class="math">g ‚àò f</span>
                means "g after f". This equivalence holds in the quotient category precisely when <span
                    class="math">p</span> considers
                <span class="math">a<sub>(q)</sub></span> equal to <span class="math">b<sub>(r)</sub></span>.
            </p>
            <p>
                <strong>(‚áê) Assume <span class="math">f<sub>(a, q ‚Üí p)</sub> ‚àò f<sub>(b, r ‚Üí p)</sub> ‚â°
                        id<sub>p</sub></span>:</strong>
            </p>
            <p>
                Since <span class="math">f<sub>(a, q ‚Üí p)</sub> ‚àò f<sub>(b, r ‚Üí p)</sub> = f<sub>((b,a), r ‚Üí
                        p)</sub></span>, and this
                is equivalent to <span class="math">id<sub>p</sub> = f<sub>(true<sub>0</sub>, p ‚Üí p)</sub></span>, we
                know that <span class="math">(b,a) ‚àº true<sub>0</sub></span> under our equivalence relation on value
                histories.
            </p>
            <p>
                By the definition of our category, this equivalence indicates that perspective <span
                    class="math">p</span> evaluates the composition of <span class="math">b<sub>(r)</sub></span>
                followed by
                <span class="math">a<sub>(q)</sub></span> as identical to <span class="math">true<sub>0</sub></span>
                from its own
                perspective. This precisely corresponds to <span class="math">R<sub>p</sub>(q, r, a, b) = true</span>,
                completing the proof. ‚ñ°
            </p>
        </div>

        <h3>3.7 Negation and Logical Operations</h3>
        <p>
            To handle the liar paradox, we need to formalize negation within our framework. We define how logical
            operations, particularly negation, operate on subjective numbers:
        </p>

        <div class="definition-box">
            <h3>Definition 3.7.1 (Negation in Subjective Numbers)</h3>
            <p>For any morphism <span class="math">f<sub>(a, p ‚Üí q)</sub></span>, its negation is defined as the
                morphism
                <span class="math">f<sub>(¬¨a, p ‚Üí q)</sub></span> where <span class="math">¬¨a</span> is the Boolean
                complement of <span class="math">a</span> in <span class="math-set">V</span>.
            </p>
        </div>

        <p>
            This definition ensures that negation preserves the perspective structure while transforming the truth
            value. Similarly, we can define other logical operations:
        </p>

        <div class="definition-box">
            <h3>Definition 3.7.2 (Conjunction and Disjunction)</h3>
            <p>For morphisms <span class="math">f<sub>(a, p ‚Üí q)</sub></span> and <span class="math">f<sub>(b, p ‚Üí
                        q)</sub></span>
                with the same source and target:</p>
            <ul style="font-size: 18px;">
                <li>Conjunction: <span class="math">f<sub>(a, p ‚Üí q)</sub> ‚àß f<sub>(b, p ‚Üí q)</sub> = f<sub>(a ‚àß b, p ‚Üí
                            q)</sub></span></li>
                <li>Disjunction: <span class="math">f<sub>(a, p ‚Üí q)</sub> ‚à® f<sub>(b, p ‚Üí q)</sub> = f<sub>(a ‚à® b, p ‚Üí
                            q)</sub></span></li>
            </ul>
        </div>

        <p>
            These definitions ensure that within a single perspective, logical operations behave classically. This is
            formalized in the following theorem:
        </p>

        <div class="theorem">
            <strong>Theorem 3.3 (Preservation of Classical Logic):</strong> Within any single perspective <span
                class="math">p ‚àà <span class="math-set">P</span></span>, the logical operations of negation,
            conjunction, and disjunction
            satisfy all the laws of classical Boolean logic.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> For any perspective <span class="math">p</span> and values <span class="math">a,
                    b, c ‚àà <span class="math-set">V</span></span>, we need to verify that the basic laws of Boolean
                algebra hold:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Complement Laws:</strong>
                    <br><span class="math">a ‚àß ¬¨a = false<sub>0</sub></span> and <span class="math">a ‚à® ¬¨a =
                        true<sub>0</sub></span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Idempotent Laws:</strong>
                    <br><span class="math">a ‚àß a = a</span> and <span class="math">a ‚à® a = a</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Commutative Laws:</strong>
                    <br><span class="math">a ‚àß b = b ‚àß a</span> and <span class="math">a ‚à® b = b ‚à®
                        a</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Associative Laws:</strong>
                    <br><span class="math">(a ‚àß b) ‚àß c = a ‚àß (b ‚àß c)</span> and <span class="math">(a ‚à® b) ‚à® c = a ‚à® (b
                        ‚à® c)</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Distributive Laws:</strong>
                    <br><span class="math">a ‚àß (b ‚à® c) = (a ‚àß b) ‚à® (a ‚àß c)</span> and <span class="math">a ‚à® (b ‚àß c) =
                        (a ‚à® b) ‚àß (a ‚à® c)</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Identity Laws:</strong>
                    <br><span class="math">a ‚àß true<sub>0</sub> = a</span> and <span class="math">a ‚à® false<sub>0</sub>
                        = a</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Domination Laws:</strong>
                    <br><span class="math">a ‚àß false<sub>0</sub> = false<sub>0</sub></span> and <span class="math">a ‚à®
                        true<sub>0</sub> =
                        true<sub>0</sub></span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>Absorption Laws:</strong>
                    <br><span class="math">a ‚àß (a ‚à® b) = a</span> and <span class="math">a ‚à® (a ‚àß b) =
                        a</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
                <li><strong>De Morgan's Laws:</strong>
                    <br><span class="math">¬¨(a ‚àß b) = ¬¨a ‚à® ¬¨b</span> and <span class="math">¬¨(a
                        ‚à® b) = ¬¨a ‚àß ¬¨b</span>
                    <br>These hold because <span class="math-set">V</span> is a Boolean algebra.
                </li>
            </ol>
            <p>
                Since all Boolean algebra laws are preserved in the value space <span class="math-set">V</span>,
                and our definitions of logical operations on morphisms directly use the corresponding operations in
                <span class="math-set">V</span>, all classical logical laws are preserved within any single
                perspective. ‚ñ°
            </p>
        </div>

        <div class="key-takeaways">
            <h3>Key Takeaways: The Subjective Numbers Framework</h3>
            <ul style="font-size: 18px;">

                <li>Subjective numbers incorporate intrinsic perspective, represented as morphisms in a category</li>
                <li>The relation function <span class="math">R<sub>p</sub></span> formalizes how perspective <span
                        class="math">p</span> evaluates equality between subjective numbers</li>
                <li>The category <span class="math">ùì¢ùìù</span> has perspectives as objects and subjective
                    evaluations as morphisms</li>
                <li>Composition of morphisms models perspective transitions, capturing the history of evaluations</li>
                <li>Within any single perspective, classical Boolean logic is preserved</li>
                <li>The cross-perspective adoption function controls when transitivity extends across perspectives</li>
            </ul>
        </div>

        <div class="figure">
            <img src="images/liar_paradox1.jpg" alt="Category Theoretic Framework" />
            <p class="caption">Category-Theoretic Framework of Subjective Numbers</p>
        </div>

        <h3>3.8 Morphism-Logic Correspondence</h3>
        <p>
            We now establish a formal correspondence between the categorical structure of our framework and logical
            inference systems. This correspondence elucidates how morphism composition directly implements
            perspective-dependent reasoning.
        </p>

        <div class="theorem">
            <strong>Theorem 3.4 (Morphism-Logic Isomorphism):</strong> There exists an isomorphism between:
            <ol style="font-size: 18px;">
                <li>Valid compositions of morphisms in the category <span class="math">ùì¢ùìù</span></li>
                <li>Valid inference steps in a perspective-indexed logical system <span class="math">‚Ñí<sub
                            class="math-subscript">ùí´</sub></span></li>
            </ol>
            This isomorphism preserves the structure of inference and composition, establishing that categorical
            composition precisely captures perspective-dependent logical reasoning.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> We construct the isomorphism <span class="math">Œ¶</span> explicitly:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>From Morphisms to Inference Steps:</strong> For any morphism <span class="math">f<sub
                            class="math-subscript">(<span class="math">a</span>, <span class="math">p</span> <span
                                class="math-op">‚Üí</span>
                            <span class="math">q</span>)</sub></span>, we define:
                    <div class="math-block">
                        <span class="math">Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                        class="math">a</span>, <span class="math">p</span> <span
                                        class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                                class="math-op">=</span> [<span class="math">p</span> <span class="math-op">‚ä¢</span>
                            <span class="math">a</span>] <span class="math-op">‚áí</span> [<span class="math">q</span>
                            <span class="math-op">‚ä¢</span> <span class="math">a</span>]</span>
                    </div>
                    where <span class="math">[<span class="math">p</span> <span class="math-op">‚ä¢</span> <span
                            class="math">a</span>]</span> denotes "perspective <span class="math">p</span> asserts
                    value <span class="math">a</span>".
                </li>
                <li><strong>From Morphism Composition to Inference Chains:</strong> For composable morphisms:
                    <div class="math-block">
                        <span class="math">Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                        class="math">b</span>, <span class="math">q</span> <span
                                        class="math-op">‚Üí</span> <span class="math">r</span>)</sub></span> <span
                                class="math-op">‚àò</span> <span class="math">f<sub class="math-subscript">(<span
                                        class="math">a</span>, <span class="math">p</span> <span
                                        class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                                class="math-op">=</span> Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                        class="math">b</span>, <span class="math">q</span> <span
                                        class="math-op">‚Üí</span> <span class="math">r</span>)</sub></span>) <span
                                class="math-op">‚àò</span> Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                        class="math">a</span>, <span class="math">p</span> <span
                                        class="math-op">‚Üí</span>
                                    <span class="math">q</span>)</sub></span>)</span>
                    </div>
                    <div class="math-block">
                        <span class="math"><span class="math-op">=</span> ([<span class="math">q</span> <span
                                class="math-op">‚ä¢</span> <span class="math">b</span>] <span class="math-op">‚áí</span>
                            [<span class="math">r</span> <span class="math-op">‚ä¢</span> <span class="math">b</span>])
                            <span class="math-op">‚àò</span> ([<span class="math">p</span> <span class="math-op">‚ä¢</span>
                            <span class="math">a</span>] <span class="math-op">‚áí</span> [<span class="math">q</span>
                            <span class="math-op">‚ä¢</span> <span class="math">a</span>])</span>
                    </div>
                    <div class="math-block">
                        <span class="math"><span class="math-op">=</span> [<span class="math">p</span> <span
                                class="math-op">‚ä¢</span> <span class="math">a</span>] <span class="math-op">‚áí</span>
                            [<span class="math">r</span> <span class="math-op">‚ä¢</span> <span
                                class="math">b</span>]</span>
                    </div>
                    This corresponds to the transitivity of perspective-dependent inference in logical system <span
                        class="math">‚Ñí<sub class="math-subscript">ùí´</sub></span>.
                </li>
                <li><strong>Identity Preservation:</strong> For any perspective <span class="math">p</span>:
                    <div class="math-block">
                        <span class="math">Œ¶(<span class="math">id<sub class="math-subscript">p</sub></span>) <span
                                class="math-op">=</span> Œ¶(<span class="math">f<sub class="math-subscript">((<span
                                        class="math">true<sub class="math-subscript">0</sub></span>, <span
                                        class="math">p</span> <span class="math-op">‚Üí</span> <span
                                        class="math">p</span>)</sub></span>) <span class="math-op">=</span> [<span
                                class="math">p</span> <span class="math-op">‚ä¢</span> <span class="math">true<sub
                                    class="math-subscript">0</sub></span>] <span class="math-op">‚áí</span> [<span
                                class="math">p</span> <span class="math-op">‚ä¢</span>
                            <span class="math">true<sub class="math-subscript">0</sub></span>]</span>
                    </div>
                    This corresponds to the reflexivity axiom in <span class="math">‚Ñí<sub
                            class="math-subscript">ùí´</sub></span>.
                </li>
                <li><strong>Logical Operations:</strong> The logical operations of conjunction, disjunction, and
                    negation correspond directly to categorical operations on morphisms:
                    <ul style="font-size: 18px;">
                        <li>Negation: <span class="math">Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                            class="math">¬¨a</span>, <span class="math">p</span> <span
                                            class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                                    class="math-op">=</span> [<span class="math">p</span> <span class="math-op">‚ä¢</span>
                                <span class="math">¬¨a</span>] <span class="math-op">‚áí</span> [<span
                                    class="math">q</span> <span class="math-op">‚ä¢</span> <span
                                    class="math">¬¨a</span>]</span></li>
                        <li>Conjunction: <span class="math">Œ¶(<span class="math">f<sub class="math-subscript">((<span
                                            class="math">a</span> <span class="math-op">‚àß</span> <span
                                            class="math">b</span>), <span class="math">p</span> <span
                                            class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                                    class="math-op">=</span> [<span class="math">p</span> <span class="math-op">‚ä¢</span>
                                <span class="math">a</span> <span class="math-op">‚àß</span> <span class="math">b</span>]
                                <span class="math-op">‚áí</span> [<span class="math">q</span>
                                <span class="math-op">‚ä¢</span> <span class="math">a</span> <span
                                    class="math-op">‚àß</span> <span class="math">b</span>]</span></li>
                        <li>Disjunction: <span class="math">Œ¶(<span class="math">f<sub class="math-subscript">((<span
                                            class="math">a</span> <span class="math-op">‚à®</span> <span
                                            class="math">b</span>), <span class="math">p</span> <span
                                            class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                                    class="math-op">=</span> [<span class="math">p</span> <span class="math-op">‚ä¢</span>
                                <span class="math">a</span> <span class="math-op">‚à®</span> <span class="math">b</span>]
                                <span class="math-op">‚áí</span> [<span class="math">q</span> <span
                                    class="math-op">‚ä¢</span> <span class="math">a</span>
                                <span class="math-op">‚à®</span> <span class="math">b</span>]</span></li>
                    </ul>
                </li>
            </ol>
            <p>
                <strong>Verification of Isomorphism Properties:</strong>
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Injectivity:</strong> If <span class="math">Œ¶(<span class="math">f<sub
                                class="math-subscript">(<span class="math">a</span>, <span class="math">p</span> <span
                                    class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span>) <span
                            class="math-op">=</span> Œ¶(<span class="math">f<sub class="math-subscript">(<span
                                    class="math">b</span>, <span class="math">r</span> <span class="math-op">‚Üí</span>
                                <span class="math">s</span>)</sub></span>)</span>,
                    then <span class="math">[<span class="math">p</span> <span class="math-op">‚ä¢</span> <span
                            class="math">a</span>] <span class="math-op">‚áí</span> [<span class="math">q</span> <span
                            class="math-op">‚ä¢</span> <span class="math">a</span>] <span class="math-op">=</span> [<span
                            class="math">r</span> <span class="math-op">‚ä¢</span> <span class="math">b</span>] <span
                            class="math-op">‚áí</span> [<span class="math">s</span> <span class="math-op">‚ä¢</span> <span
                            class="math">b</span>]</span>, which
                    implies <span class="math">p</span> <span class="math-op">=</span> <span class="math">r</span>,
                    <span class="math">q</span> <span class="math-op">=</span> <span class="math">s</span>, and <span
                        class="math">a</span> <span class="math-op">=</span>
                    <span class="math">b</span>. Therefore, <span class="math">f<sub class="math-subscript">(<span
                                class="math">a</span>, <span class="math">p</span> <span class="math-op">‚Üí</span> <span
                                class="math">q</span>)</sub></span> <span class="math-op">=</span> <span
                        class="math">f<sub class="math-subscript">(<span class="math">b</span>, <span
                                class="math">r</span> <span class="math-op">‚Üí</span> <span
                                class="math">s</span>)</sub></span>, establishing
                    injectivity.
                </li>
                <li><strong>Surjectivity:</strong> Any valid inference step <span class="math">[<span
                            class="math">p</span> <span class="math-op">‚ä¢</span> <span class="math">a</span>] <span
                            class="math-op">‚áí</span> [<span class="math">q</span> <span class="math-op">‚ä¢</span>
                        <span class="math">a</span>]</span> in <span class="math">‚Ñí<sub
                            class="math-subscript">ùí´</sub></span> corresponds to a morphism <span class="math">f<sub
                            class="math-subscript">(<span class="math">a</span>, <span class="math">p</span> <span
                                class="math-op">‚Üí</span> <span class="math">q</span>)</sub></span> in <span
                        class="math">ùì¢ùìù</span>, establishing surjectivity.
                </li>
                <li><strong>Compositional Preservation:</strong> As demonstrated above, <span class="math">Œ¶</span>
                    preserves composition: <span class="math">Œ¶(<span class="math">g</span> <span
                            class="math-op">‚àò</span> <span class="math">f</span>) <span class="math-op">=</span> Œ¶(<span
                            class="math">g</span>) <span class="math-op">‚àò</span> Œ¶(<span class="math">f</span>)</span>
                    for composable
                    morphisms <span class="math">f</span> and <span class="math">g</span>.</li>
            </ol>
        </div>
        <p>
            This isomorphism demonstrates that our categorical framework provides a precise implementation of
            perspective-dependent logical inference. The cross-perspective adoption function (CPA) corresponds
            exactly to rules of inference that allow transitivity across perspectives:
        </p>
        <div class="math-block">
            <span class="math">CPA<sub class="math-subscript">p</sub>(q, r)</span> <span class="math-op">=</span>
            <span class="math">true</span> <span class="math-op">‚ü∫</span> <span class="math">([<span
                    class="math">p</span> <span class="math-op">‚ä¢</span> <span class="math">a</span>] <span
                    class="math-op">‚áí</span> [<span class="math">q</span> <span class="math-op">‚ä¢</span> <span
                    class="math">b</span>])</span> <span class="math-op">‚àß</span> <span class="math">([<span
                    class="math">q</span> <span class="math-op">‚ä¢</span> <span class="math">b</span>] <span
                    class="math-op">‚áí</span> [<span class="math">r</span>
                <span class="math-op">‚ä¢</span> <span class="math">c</span>])</span> <span class="math-op">‚ä¢</span>
            <span class="math">([<span class="math">p</span> <span class="math-op">‚ä¢</span> <span class="math">a</span>]
                <span class="math-op">‚áí</span> [<span class="math">r</span> <span class="math-op">‚ä¢</span> <span
                    class="math">c</span>])</span>
        </div>
        <p>
            This mapping establishes not only that category theory can express logical inference, but that the
            specific structure of our quotient category <span class="math">ùì¢ùìù</span> precisely implements the
            inference rules of a perspective-dependent logic, with each morphism corresponding to an inference step
            and composition corresponding to inference chains. ‚ñ°
        </p>
        </div>

        <div class="example-box">
            <h3>Example 3.8.1: The Syllogism in Subjective Numbers</h3>
            <p>Consider the classic syllogism:</p>
            <ul style="font-size: 18px;">
                <li>All men are mortal.</li>
                <li>Socrates is a man.</li>
                <li>Therefore, Socrates is mortal.</li>
            </ul>
            <p>
                In our framework, this can be expressed as a composition of morphisms:
            </p>
            <ul style="font-size: 18px;">
                <li><span class="math">f<sub>(mortal(Socrates), p<sub class="math-subscript">Socrates</sub> ‚Üí p<sub
                                class="math-subscript">Man</sub>)</sub></span>: Perspective
                    of Socrates transitioning to the perspective of Man</li>
                <li><span class="math">f<sub>(mortal(Man), p<sub class="math-subscript">Man</sub> ‚Üí p<sub
                                class="math-subscript">Mortality</sub>)</sub></span>: Perspective of
                    Man transitioning to the perspective of Mortality</li>
                <li><span class="math">f<sub>(mortal(Socrates), p<sub class="math-subscript">Socrates</sub> ‚Üí p<sub
                                class="math-subscript">Mortality</sub>)</sub> =
                        f<sub>(mortal(Man), p<sub class="math-subscript">Man</sub> ‚Üí p<sub
                                class="math-subscript">Mortality</sub>)</sub> ‚àò f<sub>(mortal(Socrates),
                            p<sub class="math-subscript">Socrates</sub> ‚Üí p<sub
                                class="math-subscript">Man</sub>)</sub></span>: The composite inference</li>
            </ul>
            <p>
                This illustrates how logical inference is directly implemented through morphism composition, with each
                step representing a perspective transition that preserves the relevant evaluation.
            </p>
        </div>

        <p>
            The morphism-logic correspondence established above demonstrates that our framework provides a fully
            expressive logical system that naturally accommodates perspective-dependent reasoning. This correspondence
            will be particularly important in understanding how our resolution of the liar paradox preserves logical
            inference while avoiding contradiction.
        </p>
        <!-- =================== LIAR PARADOX RESOLUTION =================== -->
        <h2>4. Formal Resolution of the Liar Paradox</h2>
        <p>
            We now apply the framework to resolve the liar paradox by modeling it as a cycle of perspective transitions.
        </p>

        <h3>4.1 Modeling the Liar Statement as a Morphism</h3>
        <p>
            Let <span class="math">L</span> denote the liar statement "This statement is false." We model <span
                class="math">L</span> by a morphism
        </p>
        <div class="math-block">
            <span class="math">f<sub>(œÑ(L), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
        </div>
        <p>
            where:
        </p>
        <ul style="font-size: 18px;">
            <li><span class="math">p<sub>L</sub></span> is the intrinsic perspective of the liar statement.</li>
            <li><span class="math">œÑ(L) ‚àà</span> <span class="math-set">V</span> is the truth value assigned to
                <span class="math">L</span>.
            </li>
        </ul>
        <p>
            The liar statement essentially asserts that its own truth value is <span class="math">false</span>. In our
            framework, this self-referential assertion is modeled through perspective transitions.
        </p>

        <div class="example-box">
            <h3>Example 4.1.1: Liar Statement as a Morphism</h3>
            <p>Continuing with our example perspectives <span class="math">P<sub>1</sub></span> and <span
                    class="math">P<sub>2</sub></span>,
                we model the liar statement as initially having some truth value <span class="math">œÑ(L)</span> in
                perspective <span class="math">P<sub>1</sub></span>:</p>
            <ul style="font-size: 18px;">
                <li>Initial representation: <span class="math">f<sub>(œÑ(L), P<sub>1</sub> ‚Üí P<sub>1</sub>)</sub></span>
                </li>
                <li>When viewed from perspective <span class="math">P<sub>2</sub></span>: <span
                        class="math">f<sub>(œÑ(L), P<sub>1</sub> ‚Üí
                            P<sub>2</sub>)</sub></span></li>
                <li>The negation operation in <span class="math">P<sub>2</sub></span>: <span class="math">f<sub>(¬¨œÑ(L),
                            P<sub>2</sub> ‚Üí
                            P<sub>1</sub>)</sub></span></li>
                <li>Composing these: <span class="math">f<sub>(¬¨œÑ(L), P<sub>2</sub> ‚Üí P<sub>1</sub>)</sub> ‚àò
                        f<sub>(œÑ(L), P<sub>1</sub> ‚Üí P<sub>2</sub>)</sub>
                        = f<sub>((œÑ(L),¬¨œÑ(L)), P<sub>1</sub> ‚Üí P<sub>1</sub>)</sub></span></li>
            </ul>
            <p>This composition creates a cycle that captures the self-referential nature of the liar statement.</p>
        </div>

        <h3>4.2 Resolving Self-Reference via Morphism Composition</h3>
        <p>
            To capture self-reference, we introduce a temporary perspective shift using a second perspective <span
                class="math">p<sub>E</sub></span> (an external evaluative perspective distinct from <span
                class="math">p<sub>L</sub></span>). The self-evaluation of the liar statement is then represented by the
            following steps:
        </p>
        <ol style="font-size: 18px;">
            <li><strong>Perspective Transition:</strong> The liar statement is first "viewed" from the external
                perspective <span class="math">p<sub>E</sub></span> via the morphism
                <div class="math-block">
                    <span class="math">f<sub>(œÑ(L), p<sub>L</sub> ‚Üí p<sub>E</sub>)</sub></span>
                </div>
                This represents the initial evaluation of the liar statement from an external viewpoint. The intrinsic
                truth value <span class="math">œÑ(L)</span> is preserved in this transition, but now being considered
                from perspective <span class="math">p<sub>E</sub></span>.
            </li>
            <li><strong>Complement Operation:</strong> We then apply a complementing morphism
                <div class="math-block">
                    <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub></span>
                </div>
                where the operation <span class="math">¬¨</span> denotes Boolean negation in <span
                    class="math-set">V</span>. This represents the "falsehood" assertion in the liar statement‚Äîthis
                morphism explicitly implements the semantic content of "this statement is false" by applying the
                negation operator as we transition back to the original perspective.
            </li>
            <li><strong>Composition:</strong> The overall self-evaluation is given by the composition:
                <div class="math-block">
                    <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                            p<sub>E</sub>)</sub> = f<sub>((œÑ(L),¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
                </div>
                This composite morphism follows our standard categorical notation where <span class="math">g ‚àò f</span>
                means "g after f" ‚Äî first apply <span class="math">f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub></span> to transition to the external perspective, then apply <span
                    class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub></span> to negate and return to the
                original perspective. The resulting morphism records both the original truth value <span
                    class="math">œÑ(L)</span> and its complement, with the transition returning to the original
                perspective <span class="math">p<sub>L</sub></span>. The parenthesized pair <span class="math">(œÑ(L),
                    ¬¨)</span> represents the value history of the morphism, tracking the sequence of operations applied
                during the perspective transitions.
            </li>
        </ol>
        <p>
            This construction produces a cyclic structure:
        </p>
        <ul style="font-size: 18px;">
            <li>From <span class="math">p<sub>L</sub></span>, the statement has truth value <span
                    class="math">œÑ(L)</span>.
            </li>
            <li>Transitioning to <span class="math">p<sub>E</sub></span> evaluates the statement.</li>
            <li>The complement morphism brings the evaluation back to <span class="math">p<sub>L</sub></span> as <span
                    class="math">¬¨œÑ(L)</span>.</li>
        </ul>
        <p>
            The significance of this construction is that it transforms what appears as a direct contradiction in
            classical logic (<span class="math">œÑ(L) = ¬¨œÑ(L)</span>) into a well-defined cycle of perspective
            transitions in our framework. Rather than collapsing into a paradoxical assertion, the truth value
            "oscillates" in a controlled manner that can be formally represented within the category <span
                class="math">ùì¢ùìù</span>. This cycle is the precise mathematical representation of the liar
            paradox in our framework.
        </p>

        <div class="figure">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 500">
                <!-- Background gradient -->
                <defs>
                    <linearGradient id="bg-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#f9f9f9" />
                        <stop offset="100%" stop-color="#f0f0f0" />
                    </linearGradient>

                    <!-- Arrow marker -->
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
                    </marker>

                    <!-- Curved arrow marker -->
                    <marker id="curved-arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#0056b3" />
                    </marker>
                </defs>

                <!-- Background -->
                <rect width="800" height="500" fill="url(#bg-gradient)" />

                <!-- Title -->
                <text x="400" y="40" font-family="Arial, sans-serif" font-size="24" font-weight="bold"
                    text-anchor="middle" fill="#333">
                    Resolving the Liar Paradox Through Perspective Shifts
                </text>

                <!-- Subtitle -->
                <text x="400" y="70" font-family="Arial, sans-serif" font-size="16" text-anchor="middle" fill="#555">
                    How "This statement is false" creates a cycle rather than a contradiction
                </text>

                <!-- Perspective 1 (Liar statement perspective) -->
                <circle cx="200" cy="250" r="80" fill="#e6f7ff" stroke="#0056b3" stroke-width="2" />
                <text x="200" y="240" font-family="Arial, sans-serif" font-size="20" font-weight="bold"
                    text-anchor="middle" fill="#0056b3">Statement's</text>
                <text x="200" y="270" font-family="Arial, sans-serif" font-size="20" font-weight="bold"
                    text-anchor="middle" fill="#0056b3">Perspective</text>
                <text x="200" y="290" font-family="Arial, sans-serif" font-size="16" font-style="italic"
                    text-anchor="middle" fill="#0056b3">(p<tspan style="font-size:12px;" dy="0.3em">L</tspan>)</text>
                <!-- Perspective 2 (External perspective) -->
                <circle cx="600" cy="250" r="80" fill="#fff0e6" stroke="#d35400" stroke-width="2" />
                <text x="600" y="240" font-family="Arial, sans-serif" font-size="20" font-weight="bold"
                    text-anchor="middle" fill="#d35400">External</text>
                <text x="600" y="270" font-family="Arial, sans-serif" font-size="20" font-weight="bold"
                    text-anchor="middle" fill="#d35400">Perspective</text>
                <text x="600" y="290" font-family="Arial, sans-serif" font-size="16" font-style="italic"
                    text-anchor="middle" fill="#d35400">(p<tspan style="font-size:12px;" dy="0.3em">E</tspan>)</text>
                <!-- Forward arrow from Perspective 1 to 2 -->
                <path d="M 275 225 Q 400 175 525 225" fill="none" stroke="#0056b3" stroke-width="3"
                    marker-end="url(#curved-arrowhead)" />
                <!-- Bigger True box -->
                <rect x="365" y="140" width="70" height="40" rx="5" ry="5" fill="#ffffff" stroke="#0056b3"
                    stroke-width="1.5" />
                <text x="400" y="165" font-family="Arial, sans-serif" font-size="18" text-anchor="middle"
                    fill="#333">True</text>

                <!-- Return arrow from Perspective 2 to 1 with complement -->
                <path d="M 525 275 Q 400 325 275 275" fill="none" stroke="#d35400" stroke-width="3"
                    marker-end="url(#curved-arrowhead)" />
                <!-- Bigger False box -->
                <rect x="365" y="320" width="70" height="40" rx="5" ry="5" fill="#ffffff" stroke="#d35400"
                    stroke-width="1.5" />
                <text x="400" y="345" font-family="Arial, sans-serif" font-size="18" text-anchor="middle"
                    fill="#333">False</text>

                <!-- Step descriptions -->
                <rect x="50" y="400" width="700" height="70" rx="10" ry="10" fill="#f0f8ff" stroke="#333"
                    stroke-width="1" />
                <text x="400" y="425" font-family="Arial, sans-serif" font-size="16" text-anchor="middle" fill="#333">
                    Instead of a contradiction, the liar paradox becomes a cycle between perspectives:
                </text>
                <text x="400" y="455" font-family="Arial, sans-serif" font-size="16" text-anchor="middle" fill="#333">
                    When a statement calls itself false, its truth value naturally oscillates between true and false
                </text>
            </svg>
            <p class="figure-caption">Simplified visualization of the liar paradox resolution through
                perspective shifts. The truth value is evaluated from the Statement's Perspective (p<sub>L</sub>), then
                transitions to the External Perspective (p<sub>E</sub>), where negation is applied before returning to
                the original perspective. This creates a well-defined cycle rather than a contradiction.</p>
        </div>

        <h3>4.3 Consistency Verification</h3>
        <div class="theorem">
            <strong>Theorem 4.1 (Local Consistency of the Liar Statement):</strong> The cyclic morphism <span
                class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                    p<sub>E</sub>)</sub></span> is consistent with Axioms 3.5.1‚Äì3.5.7 of the subjective numbers
            framework.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> We verify consistency with each axiom individually:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Reflexivity (Axiom 3.5.1):</strong> For every perspective, including <span
                        class="math">p<sub>L</sub></span> and <span class="math">p<sub>E</sub></span>, we have <span
                        class="math">R<sub>p</sub>(p,
                        p, a, a) = true</span> for any value <span class="math">a</span>. The identity morphisms
                    <span class="math">id<sub>p<sub>L</sub></sub></span> and <span
                        class="math">id<sub>p<sub>E</sub></sub></span> are respected. The
                    composition of morphisms does not affect this reflexivity, as each perspective still considers its
                    own values self-identical.
                </li>
                <li><strong>Non-Symmetric Evaluation (Axiom 3.5.2):</strong> The distinct perspectives <span
                        class="math">p<sub>L</sub></span> and <span class="math">p<sub>E</sub></span> guarantee that
                    evaluations are not
                    forced to be symmetric. The liar statement specifically relies on this non-symmetry: the evaluation
                    of <span class="math">œÑ(L)</span> from <span class="math">p<sub>L</sub></span> as seen from <span
                        class="math">p<sub>E</sub></span> need not match the evaluation of <span
                        class="math">¬¨œÑ(L)</span>
                    from <span class="math">p<sub>E</sub></span> as seen from <span class="math">p<sub>L</sub></span>.
                </li>
                <li><strong>Subjective Transitivity (Axiom 3.5.3):</strong> Within each fixed perspective (whether <span
                        class="math">p<sub>L</sub></span> or <span class="math">p<sub>E</sub></span>), the relation
                    function <span class="math">R<sub>p</sub></span> remains transitive. The composition <span
                        class="math">f<sub>(¬¨, p<sub>E</sub>‚Üí
                            p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub>‚Üíp<sub>E</sub>)</sub></span> respects this
                    transitivity at each step, even
                    though it creates a cycle across perspectives.</li>
                <li><strong>Cross-Perspective Inference (Axiom 3.5.4):</strong> We can set <span
                        class="math">CPA<sub>p<sub>L</sub></sub>(p<sub>E</sub>,
                        p<sub>L</sub>) = true</span> so that the inference across perspectives is allowed to complete
                    the
                    cycle. This enables <span class="math">p<sub>L</sub></span> to adopt evaluations from <span
                        class="math">p<sub>E</sub></span> about itself, which is precisely what the liar statement
                    requires.</li>
                <li><strong>Value Consistency (Axiom 3.5.5):</strong> The complement operation <span
                        class="math">¬¨</span>
                    is well-defined in the Boolean algebra <span class="math-set">V</span>
                    and preserves value consistency. If <span class="math">a = b</span> in <span
                        class="math-set">V</span>, then <span class="math">¬¨a = ¬¨b</span> in <span
                        class="math-set">V</span>, ensuring that value equality is preserved under complementation.</li>
                <li><strong>Perspective Adoption (Axiom 3.5.6):</strong> The composition <span class="math">f<sub>(¬¨,
                            p<sub>E</sub>‚Üí
                            p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub>‚Üíp<sub>E</sub>)</sub></span> exemplifies
                    perspective adoption, as the truth
                    value transitions from <span class="math">p<sub>L</sub></span> to <span
                        class="math">p<sub>E</sub></span> and then back
                    to <span class="math">p<sub>L</sub></span>. This follows exactly the composition rule defined in
                    Axiom 3.5.6,
                    creating a morphism that records the history of evaluations.</li>
                <li><strong>Perspective Distinctness (Axiom 3.5.7):</strong> Since <span class="math">p<sub>L</sub> ‚â†
                        p<sub>E</sub></span>,
                    we can ensure they have distinct evaluation behavior. In particular, the complementation represented
                    by <span class="math">f<sub>(¬¨, p<sub>E</sub>‚Üíp<sub>L</sub>)</sub></span> creates a clear
                    distinction between how <span class="math">p<sub>L</sub></span> and <span
                        class="math">p<sub>E</sub></span> evaluate truth, fulfilling this axiom.
                </li>
            </ol>
            <p>
                Therefore, the cyclic morphism representing the liar statement is completely consistent with all axioms
                of our framework. ‚ñ°
            </p>
        </div>
        <h3>4.4 Analysis of the Cyclic Structure</h3>
        <p>
            The cyclic structure we've constructed has several important properties:
        </p>
        <ol style="font-size: 18px;">
            <li><strong>Local Consistency:</strong> Within each perspective (<span class="math">p<sub>L</sub></span> or
                <span class="math">p<sub>E</sub></span>), truth evaluation remains classically consistent. There is no
                point at
                which a single perspective simultaneously holds <span class="math">A</span> and <span class="math">¬¨
                    A</span> as true. Each perspective maintains internal logical coherence.
            </li>
            <li><strong>Controlled Oscillation:</strong> The truth value oscillates between <span
                    class="math">œÑ(L)</span> and <span class="math">¬¨œÑ(L)</span> through a well-defined path of
                perspective transitions, rather than collapsing into a paradoxical <span class="math">œÑ(L) =
                    ¬¨œÑ(L)</span>. This captures the intuition that the liar statement creates a "loop" of
                self-reference.</li>
            <li><strong>Path-Dependent Evaluation:</strong> The evaluation of the liar statement depends on the path
                taken through the perspectives. This captures the intuition that self-reference inherently involves a
                cyclic process of evaluation. The outcome depends on which perspective is considered "primary" for the
                final evaluation.</li>
            <li><strong>Immunity to Explosion:</strong> The framework contains the potential contradiction within a
                controlled cycle, preventing paradoxical explosion (the principle that from a contradiction, anything
                can be derived). This is achieved without sacrificing classical logic within each perspective.</li>
        </ol>
        <p>
            Importantly, this resolution does not eliminate the cyclical nature of the liar paradox but reinterprets it
            as a meaningful structural feature rather than a contradiction. The oscillation between a value and its
            negation is preserved, but it's distributed across different perspectives rather than collapsed into a
            single contradictory statement.
        </p>

        <div class="theorem">
            <strong>Theorem 4.2 (Resolution Without Contradiction):</strong> The subjective numbers framework resolves
            the liar paradox without introducing a contradiction in any single perspective.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> The liar paradox arises in classical logic because it leads to the assertion
                <span class="math">œÑ(L) = ¬¨œÑ(L)</span>, which contradicts the law of non-contradiction. To show that our
                framework resolves this without contradiction, we must rigorously demonstrate that no single perspective
                simultaneously asserts a statement and its negation.
            </p>
            <p>
                Consider our representation of the liar statement through the composition:
            </p>
            <div class="math-block">
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L), ¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>
            <p>
                We will analyze this from each perspective's viewpoint separately:
            </p>

            <p>
                <strong>From perspective p<sub>L</sub>:</strong> At any single time t, perspective p<sub>L</sub> holds
                exactly one truth value for L. Initially, it might be <span class="math">œÑ(L) = true</span>. After one
                complete evaluation cycle, p<sub>L</sub> will hold <span class="math">œÑ(L) = false</span>. Crucially,
                p<sub>L</sub> never simultaneously holds both <span class="math">œÑ(L) = true</span> AND <span
                    class="math">œÑ(L) = false</span>. The perspective transitions through different states over time,
                but at no point does it maintain contradictory beliefs about L.
            </p>

            <p>
                <strong>From perspective p<sub>E</sub>:</strong> The external perspective p<sub>E</sub> evaluates L
                based on the value received from p<sub>L</sub>. At any given time, p<sub>E</sub> holds exactly one truth
                value for L. It never simultaneously asserts both L and ¬¨L.
            </p>

            <p>
                <strong>Formal verification of non-contradiction:</strong> Let us precisely track the truth values held
                by each perspective during the evaluation cycle:
            </p>

            <ol style="font-size: 18px;">
                <li><strong>Initial state (time t‚ÇÅ):</strong>
                    <ul style="font-size: 18px;">
                        <li>Perspective p<sub>L</sub> holds: <span class="math">œÑ(L) = v</span> (where v is either true
                            or false)</li>
                        <li>Perspective p<sub>E</sub> has no evaluation yet</li>
                    </ul>
                </li>
                <li><strong>After transition to p<sub>E</sub> (time t‚ÇÇ):</strong>
                    <ul style="font-size: 18px;">
                        <li>Perspective p<sub>L</sub> still holds: <span class="math">œÑ(L) = v</span></li>
                        <li>Perspective p<sub>E</sub> now holds: <span class="math">œÑ(L) = v</span></li>
                    </ul>
                </li>
                <li><strong>After application of complement morphism (time t‚ÇÉ):</strong>
                    <ul style="font-size: 18px;">
                        <li>Perspective p<sub>L</sub> now holds: <span class="math">œÑ(L) = ¬¨v</span> (replacing its
                            previous value)</li>
                        <li>Perspective p<sub>E</sub> still holds: <span class="math">œÑ(L) = v</span></li>
                    </ul>
                </li>
            </ol>

            <p>
                Most importantly, at no point does either perspective p<sub>L</sub> or p<sub>E</sub> simultaneously hold
                both <span class="math">œÑ(L) = true</span> AND <span class="math">œÑ(L) = false</span>. The apparent
                contradiction <span class="math">œÑ(L) = ¬¨œÑ(L)</span> is distributed across different evaluation times
                within perspective p<sub>L</sub>, preventing an actual contradiction at any single moment.
            </p>

            <p>
                <strong>Impossibility of deriving contradictions:</strong> To derive a contradiction within a single
                perspective, we would need to show that some perspective p simultaneously holds <span
                    class="math">X</span> and <span class="math">¬¨X</span> for some statement X. However, the cyclic
                evaluation pattern prevents this:
            </p>

            <ul style="font-size: 18px;">
                <li>Each perspective maintains exactly one truth value for L at any given time</li>
                <li>Truth value updates replace previous values rather than accumulate contradictions</li>
                <li>The morphisms between perspectives preserve this single-value property</li>
            </ul>

            <p>
                Since the principle of explosion (ex falso quodlibet) requires simultaneous contradictory assertions
                within a single logical context, and we have proven that such simultaneity never occurs in our
                framework, no logical explosion can result. The cyclic nature of the liar evaluation is not itself a
                contradiction but rather a well-defined mathematical structure representing the oscillation between
                truth values.
            </p>

            <p>
                Therefore, our category-theoretic framework successfully resolves the liar paradox while maintaining
                local classical consistency within each perspective, as established in Theorem 3.3 (Preservation of
                Classical Logic). ‚ñ°
            </p>
        </div>

        <h3>4.5 Immunity to Analogous Self-Referential Paradoxes</h3>
        <p>
            The framework extends naturally to any self-referential statement that asserts its own falsity. By
            introducing an appropriate external perspective and composing with a complementing morphism, similar cyclic
            structures are obtained that preserve local consistency while resolving the global paradox.
        </p>
        <p>
            For example, consider the strengthened liar paradox: "This statement is either false or undefined." In
            traditional frameworks like Kripke's, this statement creates problems because it cannot be consistently
            classified as true, false, or undefined. In our framework, we can model it using a more complex cycle
            involving multiple perspectives:
        </p>
        <ul style="font-size: 18px;">
            <li>A primary perspective <span class="math">p<sub>L</sub></span> for the statement's intrinsic viewpoint
            </li>
            <li>An external perspective <span class="math">p<sub>E</sub></span> for initial evaluation</li>
            <li>A meta-perspective <span class="math">p<sub>M</sub></span> that evaluates whether a statement has a
                defined value
            </li>
        </ul>
        <p>
            The composition of morphisms would create a cycle that captures the oscillation between different
            evaluations without collapsing into contradiction.
        </p>

        <div class="theorem">
            <strong>Theorem 4.3 (General Resolution of Self-Referential Paradoxes):</strong> Any self-referential
            paradox that involves a statement negating or otherwise modifying its own truth value can be resolved in the
            subjective numbers framework through an appropriate cycle of perspective transitions.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Let <span class="math">S</span> be any self-referential statement that asserts
                something about its own truth value, potentially creating a paradox. We can represent <span
                    class="math">S</span> generically as "This statement has property <span class="math">P</span>,"
                where <span class="math">P</span> is some property of truth values that creates the paradoxical
                situation.
            </p>
            <p>
                We model this statement using at least two perspectives:
            </p>
            <ol style="font-size: 18px;">
                <li>A primary perspective <span class="math">p<sub>S</sub></span> representing the statement's intrinsic
                    viewpoint
                </li>
                <li>An external perspective <span class="math">p<sub>E</sub></span> for evaluation</li>
            </ol>
            <p>
                For any property <span class="math">P</span> that the statement asserts about itself, we can define a
                morphism <span class="math">f<sub>(P, p<sub>E</sub> ‚Üí p<sub>S</sub>)</sub></span> that represents the
                application of property
                <span class="math">P</span> when returning from the external perspective to the statement's perspective.
                The composition:
            </p>
            <div class="math-block">
                <span class="math">f<sub>(P, p<sub>E</sub> ‚Üí p<sub>S</sub>)</sub> ‚àò f<sub>(œÑ(S), p<sub>S</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(S), P), p<sub>S</sub> ‚Üí
                        p<sub>S</sub>)</sub></span>
            </div>
            <p>
                creates a cycle that captures the self-referential nature of the statement. This structure:
            </p>
            <ul style="font-size: 18px;">
                <li>Records both the original truth value <span class="math">œÑ(S)</span> and the effect of property
                    <span class="math">P</span>
                </li>
                <li>Distributes the potentially contradictory evaluations across different perspectives and stages of
                    evaluation</li>
                <li>Maintains local consistency within each perspective</li>
            </ul>
            <p>
                Since no single perspective simultaneously holds contradictory beliefs, the framework resolves the
                paradox without sacrificing classical logic locally. If more complex self-referential structures are
                involved, we can introduce additional perspectives and appropriate morphisms to capture the full cycle
                of evaluation.
            </p>
            <p>
                The key insight is that self-reference necessarily involves a shift in perspective the statement must
                temporarily step outside itself to evaluate its own properties. This perspective shift, when properly
                formalized through category-theoretic morphisms, transforms an apparent contradiction into a
                well-defined cycle. ‚ñ°
            </p>
        </div>

        <div class="example-box">
            <h3>Example 4.5.1: Truth-Teller and Evaluative Assertion</h3>
            <h3>Truth-Teller: "This Statement is True."</h3>

            <p>
                Consider the "truth-teller" statement <span class="math">T</span>: "This statement is true."
            </p>
            <p>
                Using our framework, we model <span class="math">T</span> as follows:
            </p>
            <ol style="font-size: 18px;">
                <li>
                    Represent <span class="math">T</span> as a morphism <span class="math">f<sub>(œÑ(T), p<sub>T</sub> ‚Üí
                            p<sub>T</sub>)</sub></span>,
                    where <span class="math">p<sub>T</sub></span> is the intrinsic perspective of the truth-teller and
                    <span class="math">œÑ(T)</span> is its truth value.
                </li>
                <li>
                    Introduce an external evaluative perspective <span class="math">p<sub>E</sub></span> and a morphism
                    <span class="math">f<sub>(œÑ(T), p<sub>T</sub> ‚Üí p<sub>E</sub>)</sub></span> to capture the
                    transition from the intrinsic
                    viewpoint.
                </li>
                <li>
                    Instead of applying a complement morphism (as is necessary for resolving paradoxical
                    self-reference), we employ an identity morphism <span class="math">f<sub>(id, p<sub>E</sub> ‚Üí
                            p<sub>T</sub>)</sub></span> that
                    preserves the truth value.
                </li>
                <li>
                    The composition then yields:
                    <div class="math-block">
                        <span class="math">f<sub>(id, p<sub>E</sub> ‚Üí p<sub>T</sub>)</sub> ‚àò f<sub>(œÑ(T), p<sub>T</sub>
                                ‚Üí p<sub>E</sub>)</sub> = f<sub>((œÑ(T), id), p<sub>T</sub> ‚Üí
                                p<sub>T</sub>)</sub></span>
                    </div>
                </li>
            </ol>
            <p>
                Although both the liar and truth-teller statements are self-referential, their treatment within the
                framework differs markedly. In the case of the truth-teller, the use of the identity morphism ensures
                that the intrinsic truth value <span class="math">œÑ(T)</span> remains unchanged throughout the
                evaluation process, without invoking any cyclic or negating transformation.
            </p>
            <p>
                For <span class="math">T</span>, any morphism other than the identity would
                imply an unnecessary transformation of its truth value, thereby misrepresenting its straightforward
                assertion. To assign alternative morphisms would alter the semantic
                fidelity of the statement.
            </p>
            <p>
                Thus, the framework naturally distinguishes between paradoxical self-referential statements which
                require cyclic compositions involving negation and non-paradoxical ones like <span
                    class="math">T</span>, which are accurately modeled by a simple, direct morphism that preserves
                their truth.
            </p>

            <h3>Evaluative Assertion: "This Paper is Worth Reading."</h3>
            <p>
                Consider the statement: "This paper is worth reading."
            </p>
            <p>
                We model this assertion using our framework as follows:
            </p>
            <ol style="font-size: 18px;">
                <li>
                    Represent the statement as a morphism <span class="math">f<sub>(W(B), p<sub>B</sub> ‚Üí
                            p<sub>B</sub>)</sub></span>, where
                    <span class="math">p<sub>B</sub></span> is the intrinsic perspective of the paper, and
                    <span class="math">W(B)</span> evaluates whether the paper is "worth reading."
                </li>
                <li>
                    A reader, from an external perspective <span class="math">p<sub>R</sub></span>, evaluates the claim:
                    <div class="math-block">
                        <span class="math">f<sub>(W(B), p<sub>B</sub> ‚Üí p<sub>R</sub>)</sub></span>
                    </div>
                </li>
                <li>
                    If the reader agrees, they reinforce the statement by returning:
                    <div class="math-block">
                        <span class="math">f<sub>(W(B), p<sub>R</sub> ‚Üí p<sub>B</sub>)</sub></span>
                    </div>
                </li>
            </ol>
            <p>
                Unlike the Liar Paradox, where truth oscillates between true and false, this evaluation process remains
                stable.
                The paper asserts its own worth, and the reader either validates or rejects it based on perspective.
            </p>
            <p>
                This example demonstrates how the framework accommodates real-world assertions that involve intrinsic
                claims
                and external validation, maintaining logical consistency without paradox.
            </p>
        </div>

        <div class="key-takeaways">
            <h3>Key Takeaways: Formal Resolution of the Liar Paradox</h3>
            <ul style="font-size: 18px;">

                <li>The liar statement is modeled as a morphism that cycles through perspectives</li>
                <li>Self-reference is captured as a composition of morphisms that complement the truth value</li>
                <li>The resulting cyclic structure prevents contradiction within any single perspective</li>
                <li>This approach preserves local classical logic while handling the global cycle</li>
                <li>The framework naturally extends to other self-referential paradoxes and statements</li>
            </ul>
        </div>

        <div class="figure">
            <img src="images/liar_paradox2.jpg" alt="Cyclic Evaluation Structure" />
            <p class="caption">Cyclic evaluation structure of the liar paradox</p>
        </div>

        <!-- =================== COMPARATIVE ANALYSIS =================== -->
        <h2>5. Comparative Analysis</h2>

        <h3>5.1 Expressiveness and Consistency</h3>
        <p>
            Traditional approaches to resolving the liar paradox have focused on restricting the language or logic to
            avoid the contradiction. Our framework takes a different approach by embracing self-reference and
            reinterpreting it within a more expressive mathematical structure.
        </p>
        <table style="width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 16px;">
            <tr>
                <th style="border: 1px solid #aaa; padding: 0.5em; background-color: #eee; text-align: center;">Approach
                </th>
                <th style="border: 1px solid #aaa; padding: 0.5em; background-color: #eee; text-align: center;">
                    Self-Reference</th>
                <th style="border: 1px solid #aaa; padding: 0.5em; background-color: #eee; text-align: center;">Freedom
                    From Contradictions</th>
                <th style="border: 1px solid #aaa; padding: 0.5em; background-color: #eee; text-align: center;">
                    Expressiveness</th>
                <th style="border: 1px solid #aaa; padding: 0.5em; background-color: #eee; text-align: center;">
                    Complexity</th>
            </tr>
            <tr>
                <td style="border: 1px solid #aaa; padding: 0.5em;"><strong>Tarski's Hierarchy</strong></td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Restricted<br>(no self-ref. at 1
                    level)</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">
                    Guaranteed<br>(via language stratification)
                </td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Limited<br>(hierarchical
                    languages)</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">High<br>(infinite layers)</td>
            </tr>
            <tr>
                <td style="border: 1px solid #aaa; padding: 0.5em;"><strong>Kripke's Fixed-Point</strong></td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Partial<br>(ungrounded
                    statements)</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">
                    Guaranteed<br>(via partial truth definitions)
                </td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Moderate<br>(introduces
                    "undefined")</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Moderate</td>
            </tr>
            <tr>
                <td style="border: 1px solid #aaa; padding: 0.5em;"><strong>Paraconsistent Logic</strong></td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">
                    Allowed<br>(contradictions can appear locally)
                </td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">
                    No global explosion<br>(local contradictions are tolerated)
                </td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">High</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Moderate</td>
            </tr>
            <tr>
                <td style="border: 1px solid #aaa; padding: 0.5em;"><strong>Subjective Numbers</strong></td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Embraced<br>(via perspective
                    cycles)</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">
                    Guaranteed<br>(selective fusion disallows contradictions)
                </td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Full<br>(no forced hierarchy or
                    gaps)</td>
                <td style="border: 1px solid #aaa; padding: 0.5em; text-align: center;">Moderate<br>(managing
                    perspectives)</td>
            </tr>
        </table>

        <h3>5.1.1 Formal Expressiveness Comparison</h3>

        <p>
            We now provide a rigorous proof that our subjective numbers framework strictly subsumes the expressive power
            of alternative approaches. We establish this through a series of theorems demonstrating how our framework
            can express all valid statements in other systems while overcoming their limitations.
        </p>

        <div class="theorem">
            <strong>Theorem 5.1.1 (Subsumption of Tarski's Hierarchy):</strong> Any statement expressible within
            Tarski's hierarchy can be expressed in the subjective numbers framework without requiring a stratified
            language hierarchy.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> In Tarski's hierarchy, truth predicates are stratified across language levels:
            </p>
            <ul style="font-size: 18px;">
                <li>Language <span class="math">L<sub>0</sub></span> contains no truth predicate</li>
                <li>Language <span class="math">L<sub>1</sub></span> contains truth predicate <span
                        class="math">True<sub>1</sub></span> applicable only to <span class="math">L<sub>0</sub></span>
                    statements</li>
                <li>Language <span class="math">L<sub>n+1</sub></span> contains truth predicate <span
                        class="math">True<sub>n+1</sub></span> applicable only to <span
                        class="math">L<sub>n</sub></span> statements</li>
            </ul>

            <p>
                We can model this hierarchy in the subjective numbers framework as follows:
            </p>

            <ol style="font-size: 18px;">
                <li>Define a set of perspectives <span class="math-set">P</span> = {<span class="math">p<sub>0</sub>,
                        p<sub>1</sub>, p<sub>2</sub>, ...</span>} corresponding to each language level</li>
                <li>For any statement <span class="math">s</span> in language <span class="math">L<sub>n</sub></span>,
                    represent it as a morphism <span class="math">f<sub>(œÑ(s), p<sub>n</sub> ‚Üí
                            p<sub>n</sub>)</sub></span></li>
                <li>For any truth predicate application <span class="math">True<sub>n+1</sub>(s)</span> where <span
                        class="math">s</span> is in <span class="math">L<sub>n</sub></span>, define it as the morphism:
                    <div class="math-block">
                        <span class="math">f<sub>(œÑ(s), p<sub>n</sub> ‚Üí p<sub>n+1</sub>)</sub></span>
                    </div>
                </li>
            </ol>

            <p>
                Now we must show that this embedding preserves all valid inferences while removing unnecessary
                restrictions. For any valid inference in Tarski's hierarchy:
            </p>

            <p>
                1. <strong>Preservation of truth predicate application:</strong> The truth predicate <span
                    class="math">True<sub>n+1</sub>(s)</span> in Tarski's hierarchy corresponds to the evaluation of
                <span class="math">s</span> from perspective <span class="math">p<sub>n+1</sub></span> in our framework.
                This is represented as:
            </p>

            <div class="math-block">
                <span class="math">R<sub>p<sub>n+1</sub></sub>(p<sub>n</sub>, p<sub>n</sub>, œÑ(s), œÑ(s)) = true</span>
            </div>

            <p>
                2. <strong>Preservation of non-self-reference restriction:</strong> In Tarski's hierarchy, statements in
                <span class="math">L<sub>n</sub></span> cannot reference <span class="math">True<sub>n</sub></span> or
                higher truth predicates. In our framework, this restriction is captured by:
            </p>

            <div class="math-block">
                <span class="math">‚àÄm ‚â• n, ‚àÄs ‚àà L<sub>n</sub>, ‚àÄt ‚àà L<sub>m</sub>:
                    CPA<sub>p<sub>n</sub></sub>(p<sub>m</sub>, p<sub>n</sub>) = false</span>
            </div>

            <p>
                However, our framework offers a crucial advantage: this restriction is not inherent to the structure but
                is a specific configurable parameter via the <span class="math">CPA</span> function. We can selectively
                enable self-reference by setting:
            </p>

            <div class="math-block">
                <span class="math">CPA<sub>p<sub>n</sub></sub>(p<sub>m</sub>, p<sub>n</sub>) = true</span>
            </div>

            <p>
                3. <strong>Extension beyond the hierarchy:</strong> While we can emulate Tarski's hierarchy, our
                framework allows statements that cannot be expressed in Tarski's approach, particularly those involving
                controlled self-reference:
            </p>

            <p>
                Consider the liar statement <span class="math">L</span>. In Tarski's hierarchy, this statement cannot be
                properly formulated at any single level. In our framework, it is expressed as the composition:
            </p>

            <div class="math-block">
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L), ¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>

            <p>
                This demonstrates that our framework strictly subsumes Tarski's hierarchy: it can express everything
                Tarski's approach can express, plus statements that cannot be expressed in Tarski's framework. ‚ñ°
            </p>
        </div>

        <div class="theorem">
            <strong>Theorem 5.1.2 (Subsumption of Kripke's Fixed-Point Approach):</strong> Any statement expressible
            within Kripke's fixed-point framework can be expressed in the subjective numbers framework without requiring
            truth-value gaps.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Kripke's approach employs a three-valued logic with values {true, false,
                undefined} and assigns truth values through a monotonic process that reaches a fixed point. We
                demonstrate how our framework can represent this approach while preserving classical logic within each
                perspective.
            </p>

            <p>
                1. <strong>Representation of truth values:</strong> We define:
            </p>

            <ul style="font-size: 18px;">
                <li>For statements with value "true" in Kripke's framework, we represent them as morphisms <span
                        class="math">f<sub>(true, p<sub>K</sub> ‚Üí p<sub>K</sub>)</sub></span></li>
                <li>For statements with value "false" in Kripke's framework, we represent them as morphisms <span
                        class="math">f<sub>(false, p<sub>K</sub> ‚Üí p<sub>K</sub>)</sub></span></li>
                <li>For statements with value "undefined" in Kripke's framework, we represent them as morphisms <span
                        class="math">f<sub>(true, p<sub>K</sub> ‚Üí p<sub>U</sub>)</sub></span>, indicating a perspective
                    transition</li>
            </ul>

            <p>
                2. <strong>Representation of the fixed-point construction:</strong> Kripke's monotonic truth assignment
                process is modeled using the relation functions:
            </p>

            <ul style="font-size: 18px;">
                <li>For grounded statements assigned truth values at stage 0, define <span
                        class="math">R<sub>p<sub>K</sub></sub>(p<sub>K</sub>, p<sub>K</sub>, œÑ(s), œÑ(s)) = true</span>
                </li>
                <li>For statements receiving truth values at stage n > 0, define appropriate cross-perspective adoption
                    functions that capture the dependencies</li>
                <li>For ungrounded statements that never receive a truth value, define transitions to perspective <span
                        class="math">p<sub>U</sub></span> where their evaluation is cyclic</li>
            </ul>

            <p>
                3. <strong>Crucially, our framework transforms "undefined" statements into structured morphism cycles
                    rather than gaps in truth value.</strong> For the liar statement, which would be "undefined" in
                Kripke's framework, we have:
            </p>

            <div class="math-block">
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L), ¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>

            <p>
                4. <strong>Representation of the jump operation:</strong> Kripke's jump operation, which extends truth
                assignments at each stage, corresponds to extending the domains of relation functions <span
                    class="math">R<sub>p</sub></span> in our framework.
            </p>

            <p>
                5. <strong>Proof of strict subsumption:</strong> To demonstrate strict subsumption, we need to show (a)
                that all Kripke-expressible statements are expressible in our framework, and (b) that our framework can
                express statements that Kripke's cannot.
            </p>

            <p>
                For (a): Any statement with a definite truth value (true or false) in Kripke's framework has a direct
                representation in our framework. For "undefined" statements in Kripke's framework, we can represent them
                using perspective transitions that capture their structural properties without abandoning bivalence
                locally.
            </p>

            <p>
                For (b): Consider the strengthened liar paradox: "This statement is false or undefined." In Kripke's
                framework, this statement cannot be assigned any consistent truth value. In our framework, it can be
                represented as:
            </p>

            <div class="math-block">
                <span class="math">f<sub>(¬¨ ‚à® u, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L), ¬¨ ‚à® u), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>

            <p>
                where <span class="math">u</span> represents the predicate "is undefined". This composition creates a
                well-defined cycle that captures the statement's meaning while maintaining local consistency.
            </p>

            <p>
                Therefore, our framework strictly subsumes Kripke's approach in expressive power. ‚ñ°
            </p>
        </div>

        <div class="theorem">
            <strong>Theorem 5.1.3 (Subsumption of Paraconsistent Logic):</strong> Any statement expressible within
            paraconsistent logic can be expressed in the subjective numbers framework without requiring the acceptance
            of true contradictions.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Paraconsistent logic systems (such as Graham Priest's dialetheism) allow for
                statements that are both true and false, particularly in self-referential contexts like the liar
                paradox. We show how our framework can express the same statements without accepting contradictions
                within any single perspective.
            </p>

            <p>
                1. <strong>Representation of dialetheia:</strong> In paraconsistent logic, the liar statement <span
                    class="math">L</span> is considered both true and false simultaneously. In our framework, we
                represent this not as a contradiction within one perspective, but as a cycle of perspective transitions:
            </p>

            <div class="math-block">
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L), ¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>

            <p>
                2. <strong>Preservation of inference patterns:</strong> Paraconsistent logics modify certain inference
                rules to prevent explosion. Our framework achieves this by distributing potentially contradictory
                evaluations across different perspectives. For example, from <span class="math">p</span> and <span
                    class="math">¬¨p</span>, paraconsistent logic blocks the inference to arbitrary <span
                    class="math">q</span>. In our framework, <span class="math">p</span> and <span
                    class="math">¬¨p</span> are never simultaneously true within one perspective, so no special rules are
                needed to block explosion.
            </p>

            <p>
                3. <strong>Formal embedding:</strong> For any model <span class="math">M</span> in a paraconsistent
                logic system with truth valuation <span class="math">v</span>, we construct a model in our framework as
                follows:
            </p>

            <ul style="font-size: 18px;">
                <li>For each consistent proposition <span class="math">p</span> with <span class="math">v(p) =
                        true</span> and <span class="math">v(¬¨p) = false</span>, represent it as <span
                        class="math">f<sub>(true, p<sub>C</sub> ‚Üí p<sub>C</sub>)</sub></span></li>
                <li>For each consistent proposition <span class="math">p</span> with <span class="math">v(p) =
                        false</span> and <span class="math">v(¬¨p) = true</span>, represent it as <span
                        class="math">f<sub>(false, p<sub>C</sub> ‚Üí p<sub>C</sub>)</sub></span></li>
                <li>For each dialetheia <span class="math">p</span> with <span class="math">v(p) = true</span> and <span
                        class="math">v(¬¨p) = true</span>, represent it using perspective transitions between <span
                        class="math">p<sub>1</sub></span> and <span class="math">p<sub>2</sub></span> with appropriate
                    relation functions</li>
            </ul>

            <p>
                4. <strong>Proof of strict subsumption:</strong> Our framework goes beyond paraconsistent logic in two
                key ways:
            </p>

            <ul style="font-size: 18px;">
                <li>It preserves classical logic locally within each perspective, meaning that standard inference rules
                    remain valid in appropriate contexts</li>
                <li>It provides a more fine-grained analysis of apparent contradictions by revealing their underlying
                    cyclic structure, rather than accepting them as true contradictions</li>
            </ul>

            <p>
                For example, consider a scenario where paraconsistent logic would declare <span class="math">A</span>
                and <span class="math">¬¨A</span> both true. In our framework, these evaluations would be distributed
                across different perspectives or stages of evaluation, revealing a more nuanced structure: perhaps <span
                    class="math">A</span> holds from perspective <span class="math">p<sub>1</sub></span> while <span
                    class="math">¬¨A</span> holds from perspective <span class="math">p<sub>2</sub></span>.
            </p>

            <p>
                Therefore, our framework strictly subsumes paraconsistent logic: it can express everything
                paraconsistent logic can express, but without abandoning classical logic locally or accepting true
                contradictions. ‚ñ°
            </p>
        </div>

        <h3>5.1.2 Expressive Completeness</h3>

        <div class="theorem">
            <strong>Theorem 5.1.4 (Expressive Completeness):</strong> The subjective numbers framework is expressively
            complete with respect to self-referential statements: any coherent self-referential structure can be
            represented within the framework while maintaining local classical consistency.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> To demonstrate expressive completeness, we need to show that any
                self-referential statement, regardless of its complexity, can be represented in our framework without
                sacrificing local classical consistency.
            </p>

            <p>
                1. <strong>Representation of direct self-reference:</strong> For any statement <span
                    class="math">S</span> that directly refers to its own truth value (e.g., "This statement is X" where
                X is some property), we represent it as:
            </p>

            <div class="math-block">
                <span class="math">f<sub>(X, p<sub>E</sub> ‚Üí p<sub>S</sub>)</sub> ‚àò f<sub>(œÑ(S), p<sub>S</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(S), X), p<sub>S</sub> ‚Üí p<sub>S</sub>)</sub></span>
            </div>

            <p>
                2. <strong>Representation of indirect self-reference:</strong> For statements that indirectly refer to
                themselves through other statements (e.g., a cyclical pair of statements where each refers to the
                other), we represent them as a longer chain of morphism compositions.
            </p>

            <p>
                3. <strong>Representation of complex self-reference:</strong> For statements with complex
                self-referential structures, such as those involving quantification over all statements (e.g., "This
                statement has property P that no statement with property Q has"), we introduce additional perspectives
                and appropriate relation functions to capture the dependencies.
            </p>

            <p>
                4. <strong>Completeness proof:</strong> Given any coherent self-referential structure <span
                    class="math">S</span>, we can construct a graph <span class="math">G<sub>S</sub></span> representing
                the reference relationships between components of <span class="math">S</span>. For each node in <span
                    class="math">G<sub>S</sub></span>, we introduce a perspective in <span class="math-set">P</span>.
                For each edge in <span class="math">G<sub>S</sub></span>, we define an appropriate morphism. This
                construction guarantees that any coherent self-referential structure can be represented in our
                framework.
            </p>

            <p>
                5. <strong>Local classical consistency:</strong> Crucially, this representation maintains classical
                logic within each perspective. Any apparent contradiction that would arise in a self-referential
                structure is resolved by distributing the conflicting evaluations across different perspectives or
                stages in a cycle, rather than collapsing them into a single contradictory evaluation.
            </p>

            <p>
                This demonstrates that our framework is expressively complete with respect to self-referential
                statements while preserving local classical consistency. ‚ñ°
            </p>
        </div>

        <h3>5.1.3 A System with Mixed Statements</h3>
        <p>
            To demonstrate the practical advantages of our approach, consider a system containing both ordinary
            statements, self-referential statements, and statements referring to each other.
        </p>

        <ul style="font-size: 18px;">
            <li><strong>Tarski's Hierarchy:</strong> Requires careful stratification of statements across multiple
                language levels, making relationships between statements at different levels difficult to express. For
                example, if statement S<sub>1</sub> is at level L<sub>n</sub> and statement S<sub>2</sub> is at level
                L<sub>m</sub> where m > n, then S<sub>1</sub> cannot refer to the truth of S<sub>2</sub> within Tarski's
                framework.</li>
            <li><strong>Kripke's Fixed-Point:</strong> Creates an artificial divide between grounded and ungrounded
                statements. In a mixed system, certain statements (like the truth-teller) would be classified as
                "ungrounded" despite not being paradoxical, limiting the system's ability to work with them naturally.
            </li>
            <li><strong>Paraconsistent Logic:</strong> Handles the system but may admit contradictions that aren't
                inherently necessary, weakening the overall logical framework and potentially allowing invalid
                inferences.</li>
            <li><strong>Our Approach:</strong> Treats all statements uniformly as morphisms in the same category <span
                    class="math">ùì¢ùìù</span>, with perspective transitions modeling the relevant self-reference and
                cross-reference patterns. This preserves:
                <ul style="font-size: 18px;">
                    <li>The full expressiveness of natural language</li>
                    <li>Local classical consistency within each perspective</li>
                    <li>The ability to model arbitrary reference patterns through composition of morphisms</li>
                    <li>Fine-grained control over information flow between perspectives via the <span
                            class="math">CPA</span> function</li>
                </ul>
            </li>
        </ul>

        <p>
            For a concrete demonstration, consider the following mixed system:
        </p>

        <ul style="font-size: 18px;">
            <li><span class="math">S<sub>1</sub></span>: "Snow is white." (Ordinary statement)</li>
            <li><span class="math">S<sub>2</sub></span>: "Statement <span class="math">S<sub>1</sub></span> is true."
                (Reference to another statement)</li>
            <li><span class="math">S<sub>3</sub></span>: "This statement is true." (Truth-teller)</li>
            <li><span class="math">S<sub>4</sub></span>: "This statement is false." (Liar paradox)</li>
            <li><span class="math">S<sub>5</sub></span>: "Statement <span class="math">S<sub>4</sub></span> is true if
                and only if statement <span class="math">S<sub>3</sub></span> is false." (Mixed reference)</li>
        </ul>

        <p>
            In our framework, this system is represented as:
        </p>

        <ul style="font-size: 18px;">
            <li><span class="math">S<sub>1</sub></span>: <span class="math">f<sub>(true, p<sub>1</sub> ‚Üí
                        p<sub>1</sub>)</sub></span> (Ordinary statement with truth value "true")</li>
            <li><span class="math">S<sub>2</sub></span>: <span class="math">f<sub>(œÑ(S<sub>1</sub>), p<sub>1</sub> ‚Üí
                        p<sub>2</sub>)</sub></span> (Morphism capturing truth evaluation of <span
                    class="math">S<sub>1</sub></span> from perspective <span class="math">p<sub>2</sub></span>)</li>
            <li><span class="math">S<sub>3</sub></span>: <span class="math">f<sub>(id, p<sub>E3</sub> ‚Üí
                        p<sub>3</sub>)</sub> ‚àò f<sub>(œÑ(S<sub>3</sub>), p<sub>3</sub> ‚Üí p<sub>E3</sub>)</sub></span>
                (Truth-teller with identity morphism)</li>
            <li><span class="math">S<sub>4</sub></span>: <span class="math">f<sub>(¬¨, p<sub>E4</sub> ‚Üí
                        p<sub>4</sub>)</sub> ‚àò f<sub>(œÑ(S<sub>4</sub>), p<sub>4</sub> ‚Üí p<sub>E4</sub>)</sub></span>
                (Liar paradox with complement morphism)</li>
            <li><span class="math">S<sub>5</sub></span>: Complex composition involving the morphisms for <span
                    class="math">S<sub>3</sub></span> and <span class="math">S<sub>4</sub></span></li>
        </ul>
        <p>
            This representation allows all statements to coexist in a single, unified framework, with their semantic
            relationships precisely captured by morphism compositions. No statement must be excluded or assigned to a
            special semantic category; the framework handles ordinary statements, cross-reference, and self-reference
            with equal rigor and expressiveness.
        </p>

        <p>
            These examples and theorems demonstrate that our approach uniquely preserves both expressiveness and
            consistency, without the compromises required by alternative frameworks. Unlike paraconsistent logic, we do
            not need to sacrifice the law of non-contradiction within any perspective. Unlike Tarski's hierarchy, we can
            express arbitrary self-reference within a unified framework. And unlike Kripke's approach, we don't need to
            introduce truth-value gaps that weaken the logic's expressiveness.
        </p>

        <h3>5.2 Preservation of Classical Logic Within Perspectives</h3>
        <p>
            Within each fixed perspective (object in ùì¢ùìù), classical logic remains fully valid. The apparent
            contradiction of the liar paradox is resolved not by altering truth values globally but by allowing a
            controlled shift between perspectives.
        </p>
        <div class="theorem">
            <strong>Theorem 5.2 (Local Classicality):</strong> Within any single perspective <span class="math">p
                ‚àà</span> <span class="math-set">P</span>, the relation function <span class="math">R<sub>p</sub></span>
            satisfies all principles of classical logic including the law of non-contradiction and the law of excluded
            middle.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Consider any fixed perspective <span class="math">p ‚àà</span> <span
                    class="math-set">P</span>. The relation function <span class="math">R<sub>p</sub></span> evaluates
                whether,
                from perspective <span class="math">p</span>, one subjective number is considered equal to another. We
                need to show that classical logical principles are preserved within this evaluation.
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Law of Non-Contradiction:</strong> This principle states that a proposition and its negation
                    cannot both be true. In our framework, for any perspectives <span class="math">s, t ‚àà</span> <span
                        class="math-set">P</span> and values <span class="math">a, b ‚àà</span> <span
                        class="math-set">V</span>, we cannot have both <span class="math">R<sub>p</sub>(s, t, a, b) =
                        true</span> and <span class="math">R<sub>p</sub>(s, t, a, b) = false</span> simultaneously,
                    as <span class="math">R<sub>p</sub></span> assigns exactly one truth value to each evaluation.</li>
                <li><strong>Law of Excluded Middle:</strong> This principle states that either a proposition or its
                    negation must be true. In our framework, for any perspectives <span class="math">s, t ‚àà</span>
                    <span class="math-set">P</span> and values <span class="math">a, b ‚àà</span> <span
                        class="math-set">V</span>, either <span class="math">R<sub>p</sub>(s, t, a, b) = true</span> or
                    <span class="math">R<sub>p</sub>(s, t, a, b) = false</span>; there is no third option.
                </li>
                <li><strong>Transitivity:</strong> By Axiom 3.5.3 (Subjective Transitivity within a Perspective), if
                    <span class="math">R<sub>p</sub>(s, t, a, b) = true</span> and <span class="math">R<sub>p</sub>(t,
                        u,
                        b, c) =
                        true</span>, then <span class="math">R<sub>p</sub>(s, u, a, c) = true</span>, preserving the
                    classical property of transitivity.
                </li>
                <li><strong>Value Consistency:</strong> By Axiom 3.5.5 (Value Consistency), the relation <span
                        class="math">R<sub>p</sub></span> respects the underlying Boolean structure of <span
                        class="math-set">V</span>, ensuring that standard logical operations (conjunction, disjunction,
                    negation) behave classically.</li>
            </ol>
            <p>
                As demonstrated in Theorem 3.3 (Preservation of Classical Logic), within any single perspective, all
                Boolean algebra laws are preserved. This includes De Morgan's laws, distributivity, and all other
                classical logical equivalences.
            </p>
            <p>
                This demonstrates that within any single perspective, classical logic is fully preserved. The
                non-classical behavior arises only when transitions between perspectives are considered, particularly in
                cyclic structures like the liar paradox. ‚ñ°
            </p>
        </div>
        <p>
            This is a crucial advantage of our approach: we retain the power and intuitive appeal of classical logic in
            local contexts while gaining the expressive capability to handle self-reference through perspective
            transitions.
        </p>

        <h3>5.3 Algebraic and Categorical Advantages</h3>
        <p>
            The category-theoretic construction offers several advantages over traditional approaches:
        </p>
        <ul style="font-size: 18px;">
            <li><strong>Structured Perspective Transitions:</strong> Morphisms capture not only the value but also the
                transition path between perspectives. This allows us to track the history of evaluations and understand
                how truth values propagate through different viewpoints.</li>
            <li><strong>Quotient Construction:</strong> The use of an equivalence relation on value histories ensures
                well-defined composition and associativity. This provides a mathematically rigorous foundation for our
                approach, grounding it in established category theory.</li>
            <li><strong>Local Consistency:</strong> Although global evaluation is cyclic, every single perspective
                maintains consistency with classical logic. This preserves the intuitive power of classical reasoning
                while extending it to handle self-reference.</li>
            <li><strong>Compositional Structure:</strong> The compositional nature of categories provides a natural way
                to model the step-by-step evaluation of self-referential statements, revealing their inherent structure
                rather than treating them as special cases.</li>
            <li><strong>Extensibility:</strong> The framework can be naturally extended to handle more complex
                self-referential structures beyond simple paradoxes. The category-theoretic foundation provides a
                flexible yet rigorous basis for these extensions.</li>
        </ul>
        <p>
            These advantages make the subjective numbers framework not just a solution to the liar paradox but a
            comprehensive approach to perspective-dependent truth evaluation with broad applications.
        </p>

        <div class="key-takeaways">
            <h3>Key Takeaways: Comparative Analysis</h3>
            <ul style="font-size: 18px;">

                <li>Unlike traditional approaches, our framework preserves both expressiveness and local classical logic
                </li>
                <li>Self-reference is embraced as a natural feature rather than restricted or modified</li>
                <li>Within each perspective, all principles of classical logic remain valid</li>
                <li>The category-theoretic approach provides structured ways to track perspective transitions</li>
                <li>The framework is extensible to other self-referential structures and paradoxes</li>
            </ul>
        </div>

        <!-- =================== CONNECTIONS =================== -->
        <h2>6. Connections to Other Foundational Issues</h2>

        <h3>6.1 Relation to Modal and Multi-Valued Logics</h3>
        <p>
            Our framework bears similarities to modal logics, where truth is evaluated relative to different "worlds"
            (here, perspectives). However, there are fundamental differences that distinguish our approach.
        </p>
        <div class="theorem">
            <strong>Theorem 6.1 (Modal Logic Encoding):</strong> There exists a partial mapping from subjective numbers
            to modal logic formulas that preserves certain structural properties, but no complete embedding of
            subjective numbers into standard modal logic is possible.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> We can establish a partial mapping <span class="math">œÜ</span> from subjective
                numbers statements to modal logic as follows:
            </p>
            <ul style="font-size: 18px;">
                <li>For a statement <span class="math">a<sub>(p)</sub> =<sub>p</sub> b<sub>(q)</sub></span>, map to
                    <span class="math">‚ñ°<sub>p</sub>(a =
                        b)</span>, where <span class="math">‚ñ°<sub>p</sub></span> is a modal operator indexed by
                    perspective <span class="math">p</span>.
                </li>
                <li>For the negation <span class="math">¬¨(a<sub>(p)</sub> =<sub>p</sub> b<sub>(q)</sub>)</span>, map to
                    <span class="math">¬¨‚ñ°<sub>p</sub>(a
                        = b)</span>.
                </li>
                <li>For conjunction and disjunction, preserve the logical structure: <span class="math">œÜ(A ‚àß B) = œÜ(A)
                        ‚àß œÜ(B)</span> and <span class="math">œÜ(A ‚à® B) = œÜ(A) ‚à® œÜ(B)</span>.</li>
            </ul>
            <p>
                The formal properties of this partial mapping <span class="math">œÜ</span> include:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Domain:</strong> The domain of <span class="math">œÜ</span> is the set of well-formed
                    subjective equality statements and their logical combinations.</li>
                <li><strong>Codomain:</strong> The codomain of <span class="math">œÜ</span> is the set of modal logic
                    formulas in a multi-modal logic with necessity operators indexed by perspectives.</li>
                <li><strong>Homomorphism for logical connectives:</strong> <span class="math">œÜ</span> preserves the
                    logical structure of conjunction, disjunction, and negation.</li>
                <li><strong>Preservation of single-perspective inference:</strong> If <span class="math">a<sub>(p)</sub>
                        =<sub>p</sub>
                        b<sub>(q)</sub></span> and <span class="math">b<sub>(q)</sub> =<sub>p</sub>
                        c<sub>(r)</sub></span> imply <span class="math">a<sub>(p)</sub> =<sub>p</sub>
                        c<sub>(r)</sub></span> in subjective numbers, then <span class="math">œÜ(a<sub>(p)</sub>
                        =<sub>p</sub> b<sub>(q)</sub>) ‚àß œÜ(b<sub>(q)</sub> =<sub>p</sub> c<sub>(r)</sub>) ‚Üí
                        œÜ(a<sub>(p)</sub> =<sub>p</sub> c<sub>(r)</sub>)</span> is valid in modal logic.
                </li>
            </ol>
            <p>
                This mapping preserves the basic structure of perspective-relative evaluation. However, standard modal
                logic systems such as S4 and S5 cannot fully capture subjective numbers for three key reasons:
            </p>
            <ol style="font-size: 18px;">
                <li><strong>Intrinsic Perspective:</strong> In subjective numbers, perspectives are intrinsic to the
                    objects themselves, while in modal logic, modalities are external operators applied to propositions.
                    This fundamental difference means that in our framework, the perspective is part of the identity of
                    the value, not just a way of evaluating it.</li>
                <li><strong>Cross-Perspective Adoption:</strong> The cross-perspective adoption function <span
                        class="math">CPA<sub>p</sub>(q, r)</span> has no direct analog in standard modal logic. Modal
                    logics
                    typically have fixed accessibility relations between worlds, but do not have a mechanism for
                    conditionally controlling whether evaluations from one modal context can be adopted in another
                    depending on the specific content being evaluated.</li>
                <li><strong>Compositional Structure:</strong> The composition of morphisms in our category creates a
                    rich structure where the history of evaluations is preserved. This compositional aspect, crucial for
                    handling self-reference, has no direct parallel in standard modal logic.</li>
            </ol>
            <p>
                A concrete counterexample demonstrates the impossibility of a complete embedding: Consider the liar
                paradox in our framework, which forms a well-defined cycle with locally consistent evaluations. In
                standard modal logic, attempting to formalize a statement that refers to its own falsehood still leads
                to an inconsistent formula of the form <span class="math">‚ñ°<sub>p</sub> A ‚Üî ¬¨A</span>, which cannot be
                accommodated without violating the normal modal logic semantics.
            </p>
            <p>
                Therefore, while some aspects of subjective numbers can be expressed in modal logic, a complete
                embedding is not possible without extending the modal logic framework itself. ‚ñ°
            </p>
        </div>
        <p>
            Similarly, our framework exhibits connections to multi-valued logics, but with important differences:
        </p>
        <ul style="font-size: 18px;">
            <li><strong>Truth-Value Gaps vs. Perspective Transitions:</strong> While Kripke's approach introduces a
                third "undefined" value, our framework maintains classical Boolean values within each perspective, with
                the apparent "third status" of the liar paradox emerging from the cycle of perspective transitions.</li>
            <li><strong>Local Classicality:</strong> Unlike many multi-valued logics that modify the underlying logic
                globally, our approach preserves classical logic within each perspective, with non-classical behavior
                arising only in the transitions between perspectives.</li>
            <li><strong>Structural vs. Value-Based:</strong> Multi-valued logics introduce new truth values, whereas our
                approach introduces a new structure (perspectives and their transitions) while keeping the basic truth
                values classical.</li>
        </ul>

        <h3>6.2 Self-Reference and Fixed Points</h3>
        <p>
            The liar paradox is recast in our framework as a fixed-point problem whose resolution is achieved through a
            cyclic composition of morphisms. This view sheds new light on self-reference, suggesting that rather than
            being a logical flaw, self-reference is a natural indicator of perspective-dependence.
        </p>
        <p>
            In traditional fixed-point approaches (like Kripke's), the liar statement is assigned an "undefined" truth
            value at the fixed point. In our approach, there is no single fixed point but rather a stable cycle that
            reflects the inherent oscillation between truth values. This cycle is not a defect to be eliminated but a
            natural feature of certain self-referential structures.
        </p>
        <div class="theorem">
            <strong>Theorem 6.2 (Cyclic Fixed Point):</strong> In the subjective numbers framework, the liar paradox
            corresponds to a cyclic fixed point of the truth evaluation function, rather than a singular fixed point or
            an undefined value.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> In traditional approaches, we seek a fixed point for the truth function <span
                    class="math">T</span> such that <span class="math">T(L) = L</span>, where <span
                    class="math">L</span> is the liar statement. This leads to contradiction because <span
                    class="math">L</span> asserts <span class="math">T(L) = false</span>, so we would need <span
                    class="math">T(L) = false</span> and <span class="math">T(L) = true</span> simultaneously.
            </p>
            <p>
                In our framework, we represent the liar statement as a morphism cycle:
            </p>
            <div class="math-block">
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub> = f<sub>((œÑ(L),
                        ¬¨), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span>
            </div>
            <p>
                Let's define a truth evaluation function <span class="math">T<sub>p<sub>L</sub> ‚Üí p<sub>E</sub> ‚Üí
                        p<sub>L</sub></sub></span> that
                represents the full cycle of evaluation from <span class="math">p<sub>L</sub></span> to <span
                    class="math">p<sub>E</sub></span> and back to <span class="math">p<sub>L</sub></span>. For any truth
                value <span class="math">v</span>, this function gives:
            </p>
            <div class="math-block">
                <span class="math">T<sub>p<sub>L</sub> ‚Üí p<sub>E</sub> ‚Üí p<sub>L</sub></sub>(v) = ¬¨v</span>
            </div>
            <p>
                This function has no traditional fixed point, since no value <span class="math">v</span> satisfies <span
                    class="math">v = ¬¨v</span> in classical Boolean logic. However, if we consider the second
                iteration of this function:
            </p>
            <div class="math-block">
                <span class="math">T<sub>p<sub>L</sub> ‚Üí p<sub>E</sub> ‚Üí p<sub>L</sub></sub>(T<sub>p<sub>L</sub> ‚Üí
                        p<sub>E</sub> ‚Üí p<sub>L</sub></sub>(v)) = ¬¨(¬¨v) = v</span>
            </div>
            <p>
                This shows that <span class="math">T<sub>p<sub>L</sub> ‚Üí p<sub>E</sub> ‚Üí p<sub>L</sub></sub>^2</span>
                (the function composed with itself)
                has every value <span class="math">v</span> as a fixed point. In other words, the evaluation function
                exhibits a 2-cycle for any initial value.
            </p>
            <p>
                This cyclic fixed point precisely captures the oscillating nature of the liar paradox: no matter what
                truth value we initially assign, after one complete cycle of evaluation, we get its negation, and after
                two cycles, we return to the original value. This stable oscillation is a well-defined mathematical
                structure that replaces the contradictory singular fixed point of traditional approaches. ‚ñ°
            </p>
        </div>
        <p>
            This connection to fixed-point theory extends to other self-referential constructs in mathematics and
            computer science, such as recursive functions and data structures. Our framework suggests that these
            constructs might be better understood as inherently perspective-dependent rather than as special cases
            requiring ad hoc treatment.
        </p>

        <h3>6.3 Extensions Beyond Classical Systems</h3>
        <p>
            The abstract nature of our construction means that the framework can be reformulated in other foundational
            systems (e.g., intuitionistic set theory) as long as the underlying category-theoretic notions are
            supported.
        </p>
        <p>
            For instance, we could replace the Boolean algebra <span class="math-set">V</span> with a Heyting algebra to
            model intuitionistic truth values, or with a more complex algebraic structure to capture fuzzy or
            probabilistic truth. The core insight that perspective is intrinsic to mathematical objects and that truth
            evaluation involves transitions between perspectives remains valid across these variations.
        </p>
        <p>
            Similarly, the framework could be extended to address other semantic and logical paradoxes, such as:
        </p>
        <ul style="font-size: 18px;">
            <li><strong>Berry's Paradox:</strong> "The smallest positive integer not definable in fewer than twenty
                words." This can be modeled using perspectives that represent different levels of linguistic complexity.
            </li>
            <li><strong>Russell's Paradox:</strong> "The set of all sets that do not contain themselves." This can be
                addressed by introducing perspectives that represent different levels of set-theoretic hierarchy.</li>
            <li><strong>Curry's Paradox:</strong> "If this statement is true, then P" (where P is any proposition). This
                can be modeled using a more complex cycle of perspective transitions that captures the conditional
                structure.</li>
        </ul>

        <div class="theorem">
            <strong>Theorem 6.3 (Consistency of Subjective Numbers):</strong> The subjective numbers framework is
            consistent relative to ZF set theory.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> To prove relative consistency, we need to show that the subjective numbers
                framework can be modeled within ZF set theory without introducing any contradictions.
            </p>
            <p>
                Let us construct a model <span class="math">ùìú</span> of the subjective numbers framework in
                ZF:
            </p>
            <ol style="font-size: 18px;">
                <li>Define the set of perspectives <span class="math-set">P</span> as any non-empty set in ZF.</li>
                <li>Define the value space <span class="math-set">V</span> as the Boolean algebra <span
                        class="math">{true, false}</span> with standard operations.</li>
                <li>For each perspective <span class="math">p ‚àà</span> <span class="math-set">P</span>, define the
                    relation function <span class="math">R<sub>p</sub></span> as a function <span
                        class="math">R<sub>p</sub>: ùêè
                        √ó ùêè √ó ùêï √ó ùêï ‚Üí
                        {true, false}</span> that satisfies
                    the axioms of well-formedness.</li>
                <li>Define the cross-perspective adoption function <span class="math">CPA<sub>p</sub></span> for each
                    <span class="math">p</span> as a function <span class="math">CPA<sub>p</sub>: ùêè √ó ùêè ‚Üí
                        {true, false}</span>.
                </li>
                <li>Define the category <span class="math">ùì¢ùìù</span> with objects <span class="math">p
                        ‚àà</span> <span class="math-set">P</span> and morphisms <span class="math">f<sub>(a, p ‚Üí
                            q)</sub></span> as ordered pairs <span class="math">(a, (p, q))</span>, with composition
                    defined as
                    specified in Section 3.4.3.</li>
            </ol>
            <p>
                All of these constructions are standard set-theoretic definitions that can be formalized in ZF. The
                axioms of our framework, including the quotient category construction, can be expressed as properties of
                these sets and functions. Since ZF is known to be consistent (relative to its own consistency), and our
                framework is constructed entirely within ZF using well-defined operations, the subjective numbers
                framework is consistent relative to ZF.
            </p>
            <p>
                In particular, the cyclic representation of the liar paradox does not introduce a contradiction in this
                model, because it is simply encoded as a specific morphism with a particular compositional structure.
                The fact that truth values may oscillate when following this cycle does not violate any axioms of ZF, as
                the oscillation is captured as a mathematical structure (a cycle of morphisms) rather than as a logical
                contradiction. ‚ñ°
            </p>
        </div>


        <h3>6.4 Contradiction-Free (Selective) Fusion</h3>
        <p>
            In earlier sections, we focused on resolving self-reference within a single cyclical framework (e.g., the
            liar paradox). Another potential source of contradiction arises when multiple perspectives are
            indiscriminately merged into one vantage. To prevent such "universal vantage" contradictions, we introduce a
            <em>compatibility test</em> that governs whether two (or more) perspectives can safely fuse into a single
            perspective without triggering paradoxes akin to the liar.
        </p>

        <div class="definition-box">
            <h3>Definition 6.4.1 (Perspective Compatibility)</h3>
            <p>Two perspectives <span class="math">p, q ‚àà ùí´</span> are said to be <em>compatible</em>,
                denoted <span class="math">Compatible(p, q) = true</span>, if and only if the following condition holds:
            </p>
            <div class="math-block">
                <span class="math">‚àÄx, y ‚àà V: R<sub class="math-subscript">p</sub>(p, q, x, y) = R<sub
                        class="math-subscript">q</sub>(q, p, y, x)</span>
            </div>
            <p>This condition requires mutual agreement on all cross-perspective evaluations: whenever perspective <span
                    class="math">p</span> evaluates the relation between values <span class="math">x</span> from
                perspective <span class="math">p</span> and <span class="math">y</span> from perspective <span
                    class="math">q</span>, perspective <span class="math">q</span> must agree when evaluating the
                relation between <span class="math">y</span> from perspective <span class="math">q</span> and <span
                    class="math">x</span> from perspective <span class="math">p</span>.</p>
        </div>

        <div class="theorem">
            <strong>Theorem 6.4.1 (Necessary and Sufficient Condition for Consistent Fusion):</strong> The compatibility
            condition <span class="math">Compatible(p, q) = true</span> is both necessary and sufficient for the
            existence of a consistent fused perspective <span class="math">p ‚äï q</span> that preserves all
            evaluations from both constituent perspectives without introducing contradictions.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> We prove both necessity and sufficiency:
            </p>

            <p>
                <strong>Sufficiency:</strong> Suppose <span class="math">Compatible(p, q) = true</span>, meaning <span
                    class="math">‚àÄx, y ‚àà V: R<sub class="math-subscript">p</sub>(p, q, x, y) = R<sub
                        class="math-subscript">q</sub>(q, p, y, x)</span>. We construct the fused
                perspective <span class="math">p ‚äï q</span> with relation function:
            </p>

            <div class="math-block">
                <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, r, x, y) = f(R<sub
                        class="math-subscript">p</sub>(p, r, x, y), R<sub class="math-subscript">q</sub>(q, r, x,
                    y))</span>
            </div>

            <p>
                where <span class="math">f</span> is a fusion operator (e.g., conjunction, disjunction) that satisfies
                idempotence: <span class="math">f(a,a) = a</span> for all <span class="math">a ‚àà {true,
                    false}</span>.
            </p>

            <p>
                For the special case where <span class="math">r ‚àà {p, q}</span>, we define:
            </p>

            <div class="math-block">
                <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, p, x, y) = R<sub
                        class="math-subscript">p</sub>(p, p, x, y)</span>
            </div>
            <div class="math-block">
                <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, q, x, y) = R<sub
                        class="math-subscript">q</sub>(q, q, x, y)</span>
            </div>

            <p>
                Now, we must verify that <span class="math">R<sub class="math-subscript">p ‚äï q</sub></span> satisfies
                well-formedness conditions:
            </p>

            <ol style="font-size: 18px;">
                <li>
                    <strong>Internal Consistency (Transitivity):</strong> If <span class="math">R<sub
                            class="math-subscript">p ‚äï q</sub>(p ‚äï
                        q, s, a, b) = true</span> and <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï
                        q, t, b, c) = true</span>, then by construction, both <span class="math">R<sub
                            class="math-subscript">p</sub>(p, s, a, b) = true</span> and
                    <span class="math">R<sub class="math-subscript">q</sub>(q, s, a, b) = true</span> (assuming
                    conjunction fusion). Similarly, both
                    <span class="math">R<sub class="math-subscript">p</sub>(p, t, b, c) = true</span> and <span
                        class="math">R<sub class="math-subscript">q</sub>(q, t, b, c) =
                        true</span>. By the transitivity of <span class="math">R<sub
                            class="math-subscript">p</sub></span> and <span class="math">R<sub
                            class="math-subscript">q</sub></span> (Axiom 3), we have <span class="math">R<sub
                            class="math-subscript">p</sub>(p, s, a, c) = true</span> and
                    <span class="math">R<sub class="math-subscript">q</sub>(q, t, a, c) = true</span>, which implies
                    <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p
                        ‚äï q, s, a, c) = true</span>.
                </li>

                <li>
                    <strong>Self-Reflexivity:</strong> For all <span class="math">a ‚àà V</span>, <span class="math">R<sub
                            class="math-subscript">p ‚äï q</sub>(p ‚äï q, p ‚äï q, a, a) = f(R<sub
                            class="math-subscript">p</sub>(p, p, a, a), R<sub class="math-subscript">q</sub>(q, q, a,
                        a))
                        = f(true, true) = true</span>, by Axiom 1 and the properties of <span class="math">f</span>.
                </li>

                <li>
                    <strong>Value Invariance:</strong> If <span class="math">a = c</span> in <span
                        class="math">V</span>, then <span class="math">R<sub class="math-subscript">p</sub>(p, s, a, b)
                        = R<sub class="math-subscript">p</sub>(p, s, c, b)</span> and
                    <span class="math">R<sub class="math-subscript">q</sub>(q, s, a, b) = R<sub
                            class="math-subscript">q</sub>(q, s, c, b)</span> by Axiom 5, which implies <span
                        class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, s, a, b) = R<sub
                            class="math-subscript">p ‚äï q</sub>(p ‚äï q, s, c, b)</span>.
                </li>
            </ol>

            <p>
                Thus, <span class="math">R<sub class="math-subscript">p ‚äï q</sub></span> is well-formed. Most
                importantly, no contradiction arises
                in <span class="math">p ‚äï q</span> because the compatibility condition ensures that whenever <span
                    class="math">p</span> and <span class="math">q</span> make evaluations about each other, those
                evaluations are mutually consistent.
            </p>

            <p>
                <strong>Necessity:</strong> Now, we prove that the compatibility condition is necessary for consistent
                fusion. Suppose <span class="math">Compatible(p, q) = false</span>. Then there exist values <span
                    class="math">x<sub class="math-subscript">0</sub>, y<sub class="math-subscript">0</sub> ‚àà V</span>
                such that <span class="math">R<sub class="math-subscript">p</sub>(p, q, x<sub
                        class="math-subscript">0</sub>, y<sub class="math-subscript">0</sub>) ‚â† R<sub
                        class="math-subscript">q</sub>(q, p,
                    y<sub class="math-subscript">0</sub>, x<sub class="math-subscript">0</sub>)</span>.
            </p>

            <p>
                Without loss of generality, assume <span class="math">R<sub class="math-subscript">p</sub>(p, q, x<sub
                        class="math-subscript">0</sub>, y<sub class="math-subscript">0</sub>) = true</span> and <span
                    class="math">R<sub class="math-subscript">q</sub>(q, p, y<sub class="math-subscript">0</sub>, x<sub
                        class="math-subscript">0</sub>) = false</span>. Now, consider any attempted definition of <span
                    class="math">R<sub class="math-subscript">p ‚äï q</sub></span>:
            </p>

            <ul style="font-size: 18px;">
                <li>If we set <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, q, x<sub
                            class="math-subscript">0</sub>, y<sub class="math-subscript">0</sub>) = true</span>
                    (agreeing with
                    <span class="math">p</span>), then <span class="math">p ‚äï q</span> would contradict <span
                        class="math">q</span>'s evaluation.
                </li>
                <li>If we set <span class="math">R<sub class="math-subscript">p ‚äï q</sub>(p ‚äï q, q, x<sub
                            class="math-subscript">0</sub>, y<sub class="math-subscript">0</sub>) = false</span>
                    (agreeing with
                    <span class="math">q</span>), then <span class="math">p ‚äï q</span> would contradict <span
                        class="math">p</span>'s evaluation.
                </li>
            </ul>

            <p>
                This conflict can be exploited to construct a self-referential statement similar to the liar paradox.
                Let <span class="math">S</span> be the statement "The relationship between <span class="math">x<sub
                        class="math-subscript">0</sub></span>
                from perspective <span class="math">p</span> and <span class="math">y<sub
                        class="math-subscript">0</sub></span> from perspective <span class="math">q</span> is as
                perspective <span class="math">q</span> sees it." From perspective <span class="math">p</span>, <span
                    class="math">S</span> is false (since <span class="math">p</span>
                disagrees with <span class="math">q</span>'s evaluation), while from perspective <span
                    class="math">q</span>, <span class="math">S</span> is true. Any attempt to fuse these perspectives
                would force <span class="math">p ‚äï q</span> to simultaneously assert and deny <span
                    class="math">S</span>, creating a contradiction.
            </p>

            <p>
                Therefore, the compatibility condition is necessary for the existence of a consistent fused perspective.
                ‚ñ°
            </p>
        </div>

        <div class="theorem">
            <strong>Theorem 6.4.2 (Connection to Cross-Perspective Adoption):</strong> The compatibility condition <span
                class="math">Compatible(p, q) = true</span> implies a form of symmetric cross-perspective adoption
            between <span class="math">p</span> and <span class="math">q</span>.
        </div>

        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Recall that the cross-perspective adoption function <span class="math">CPA<sub
                        class="math-subscript">p</sub>(q,
                    r)</span> determines whether perspective <span class="math">p</span> adopts perspective <span
                    class="math">q</span>'s evaluations regarding perspective <span class="math">r</span>.
            </p>

            <p>
                When <span class="math">Compatible(p, q) = true</span>, we have <span class="math">‚àÄx, y ‚àà V:
                    R<sub class="math-subscript">p</sub>(p, q, x, y) = R<sub class="math-subscript">q</sub>(q, p, y,
                    x)</span>. This equality ensures that <span class="math">p</span> and
                <span class="math">q</span> have reciprocal evaluations of each other.
            </p>

            <p>
                For perspectives <span class="math">p</span> and <span class="math">q</span> to be fusible, they must
                effectively adopt each other's evaluations regarding all other perspectives <span class="math">r ‚àà
                    ùí´</span>. Formally, this means:
            </p>

            <div class="math-block">
                <span class="math">CPA<sub class="math-subscript">p</sub>(q, r) = true and CPA<sub
                        class="math-subscript">q</sub>(p, r) = true for all r ‚àà ùí´</span>
            </div>

            <p>
                In other words, perspective compatibility requires mutual cross-perspective adoption. When perspectives
                disagree about evaluations involving each other, this mutual adoption is impossible, which explains why
                incompatible perspectives cannot be fused without contradiction.
            </p>

            <p>
                This connection to the cross-perspective adoption function provides a deeper understanding of
                perspective compatibility in terms of the axiom system presented in Section 3. The compatibility
                condition is essentially a requirement for mutual cross-perspective adoption, ensuring that fusible
                perspectives agree on their evaluations of each other and all other perspectives. ‚ñ°
            </p>
        </div>

        <div class="example-box">
            <h3>Example 6.4.1: Computational Compatibility Testing</h3>
            <p>
                To illustrate the practical application of the compatibility test, consider a finite domain <span
                    class="math">V = {v<sub class="math-subscript">1</sub>, v<sub class="math-subscript">2</sub>, ...,
                    v<sub class="math-subscript">n</sub>}</span> and two perspectives <span class="math">p</span> and
                <span class="math">q</span> with finitely many evaluations. The compatibility test can be implemented as
                follows:
            </p>

            <ol style="font-size: 18px;">
                <li>For each pair <span class="math">(v<sub class="math-subscript">i</sub>, v<sub
                            class="math-subscript">j</sub>) ‚àà V √ó V</span>:</li>
                <ul style="font-size: 18px;">
                    <li>Check if <span class="math">R<sub class="math-subscript">p</sub>(p, q, v<sub
                                class="math-subscript">i</sub>, v<sub class="math-subscript">j</sub>) = R<sub
                                class="math-subscript">q</sub>(q, p, v<sub class="math-subscript">j</sub>, v<sub
                                class="math-subscript">i</sub>)</span></li>
                    <li>If any equality fails, return <span class="math">Compatible(p, q) = false</span></li>
                </ul>
                <li>If all equalities hold, return <span class="math">Compatible(p, q) = true</span></li>
            </ol>

            <p>
                This algorithm has complexity <span class="math">O(|V|<sup>2</sup>)</span> for finite domains and
                provides a
                definitive test for whether perspectives can be safely fused.
            </p>

            <p>
                For example, if perspective <span class="math">p</span> evaluates <span class="math">R<sub
                        class="math-subscript">p</sub>(p, q, true,
                    false) = true</span> (meaning <span class="math">true</span> from perspective <span
                    class="math">p</span> equals <span class="math">false</span> from perspective <span
                    class="math">q</span>), but perspective <span class="math">q</span> evaluates <span
                    class="math">R<sub class="math-subscript">q</sub>(q, p, false, true) = false</span>, then <span
                    class="math">Compatible(p, q) =
                    false</span> and these perspectives cannot be fused without contradiction.
            </p>
        </div>
        <div class="theorem">
            <strong>Theorem 6.4.3 (Selective Fusion Consistency):</strong> Let <span class="math">p</span> and <span
                class="math">q</span> be two perspectives whose evaluation functions are <span class="math">R<sub
                    class="math-subscript">p</sub></span>
            and <span class="math">R<sub class="math-subscript">q</sub></span>, respectively. Suppose a compatibility
            test <span class="math">Compatible(p, q)</span> returns true if and only if merging <span
                class="math">p</span> and
            <span class="math">q</span> into a single vantage <span class="math">p ‚äï q</span> does <em>not</em>
            introduce contradiction or self‚Äêreference loops. Then:
            <ol style="font-size: 18px; margin-left: 1.5em;">
                <li>If <span class="math">Compatible(p, q) = true</span>, define <span class="math">p ‚äï q</span>
                    (e.g., via conjunctive or disjunctive fusion). This new perspective's relation function, <span
                        class="math">R<sub class="math-subscript">p‚äïq</sub></span>, is constructed by applying a fusion
                    operator <span class="math">f</span> to the individual evaluations, so that for all <span
                        class="math">x, y ‚àà
                        V</span>:
                    <div class="math-block" style="font-size: 18px;">
                        <span class="math">R<sub class="math-subscript">p‚äïq</sub>(p ‚äï q, x, y) = f(R<sub
                                class="math-subscript">p</sub>(p, q, x, y), R<sub class="math-subscript">q</sub>(q, p,
                            y, x))</span>
                    </div>
                    Since <span class="math">Compatible(p, q) = true</span> ensures <span class="math">R<sub
                            class="math-subscript">p</sub>(p, q, x, y) =
                        R<sub class="math-subscript">q</sub>(q, p, y, x)</span> for all <span class="math">x, y</span>,
                    the fused evaluation is
                    well‚Äêdefined and free of internal contradiction.
                </li>
                <li>If <span class="math">Compatible(p, q) = false</span>, then there exists at least one pair <span
                        class="math">x, y ‚àà V</span> for which the evaluations conflict. Any attempt to define <span
                        class="math">R<sub class="math-subscript">p‚äïq</sub></span> in this case would yield a
                    contradiction or induce a
                    self‚Äêreference loop (e.g., a sentence that simultaneously forces "I am true" and "I am false").
                    Therefore, the system prohibits forming <span class="math">p ‚äï q</span> when <span
                        class="math">Compatible(p, q) = false</span>.
                </li>
            </ol>
        </div>
        <div class="example-box">
            <h3>Example 6.4.2: Liar Paradox via Unrestricted Fusion</h3>
            <p>
                Consider a self-referential statement <span class="math">L</span> with an intrinsic perspective <span
                    class="math">‚Ñì</span> that asserts "<em>This statement is false</em>." If the system were to allow a
                universal vantage <span class="math">U</span> that fuses all perspectives including <span
                    class="math">‚Ñì</span> then <span class="math">U</span> would include the evaluation of <span
                    class="math">L</span> by <span class="math">‚Ñì</span>. In such a case, <span class="math">U</span>
                would be forced into the contradictory condition:
            </p>
            <div class="math-block" style="font-size: 18px;">
                <em>"L is true in <span class="math">U</span> if and only if L is false in <span
                        class="math">U</span>."</em>
            </div>
            <p>
                This reintroduction of the liar paradox within a single vantage demonstrates the need for the
                compatibility test. By ensuring that <span class="math">Compatible(‚Ñì, {all other perspectives}) =
                    false</span>, the system prevents the formation of a universal vantage <span class="math">U</span>
                that would merge contradictory self-referential evaluations.
            </p>
        </div>
        <div class="example-box">
            <h3>Example 6.4.3: "Wisdom of Crowds" from Partial Fusion</h3>
            <p>
                Suppose three perspectives, <span class="math">p</span>, <span class="math">q</span>, and <span
                    class="math">r</span>, each offer a partial estimate of the weight of a hidden object. Assume that:
            </p>
            <ul style="font-size: 18px;">
                <li><span class="math">Compatible(p, q) = true</span> so that <span class="math">p ‚äï q</span> can
                    be formed without contradiction.</li>
                <li><span class="math">Compatible(q, r) = true</span> allowing for a fusion <span class="math">q ‚äï
                        r</span> with consistent evaluations.</li>
                <li><span class="math">Compatible(p, r) = false</span> because the underlying assumptions of <span
                        class="math">p</span> and <span class="math">r</span> conflict irreconcilably.</li>
            </ul>
            <p>
                In practice, one may fuse <span class="math">p</span> and <span class="math">q</span> into <span
                    class="math">p ‚äï q</span> to obtain a refined estimate based on their compatible data.
                Meanwhile, <span class="math">q ‚äï r</span> may also be formed if their assessments align. However,
                since <span class="math">p</span> and <span class="math">r</span> are incompatible, any attempt to form
                <span class="math">p ‚äï r</span> would yield contradictory results. This selective fusion ensures
                that only coherent subsets of perspectives merge to produce "wisdom of crowds," while conflicting
                viewpoints remain segregated.
            </p>
        </div>

        <div class="key-takeaways">
            <h3>Key Takeaways: Selective Fusion and Its Role in Preserving Consistency</h3>
            <ul style="font-size: 18px;">
                <li>Fusion of perspectives is permitted only when the compatibility test confirms that all evaluations
                    are in agreement, ensuring that no self-referential contradiction (such as that introduced by the
                    liar paradox) is admitted.</li>
                <li>The fused perspective inherits a well-defined relation function that combines the individual
                    evaluations via an appropriate fusion operator.</li>
                <li>Partial fusion allows the system to benefit from combined insights (e.g., "wisdom of crowds") while
                    safeguarding against the formation of a universal vantage that would merge incompatible evaluations.
                </li>
                <li>This framework seamlessly integrates the management of perspective-dependent operations with
                    rigorous consistency controls, thereby upholding local classical logic in every admissible fusion.
                </li>
            </ul>
        </div>



        <div class="figure">
            <img src="images/liar_paradox4.jpg" alt="Philosophical Implications" />
            <p class="caption">Philosophical implications of the subjective numbers framework</p>
        </div>

        <!-- =================== PHILOSOPHICAL IMPLICATIONS =================== -->
        <h2>7. Philosophical Implications</h2>

        <h3>7.1 Rethinking Truth</h3>
        <p>
            Our approach indicates that truth in self-referential contexts is not absolute but is intrinsically
            dependent on the evaluator's perspective. This reopens discussions about the nature of truth in formal
            systems and in natural language.
        </p>
        <p>
            The traditional view of truth as correspondence (a statement is true if it corresponds to reality) struggles
            with self-referential statements because the reality they refer to includes their own truth value. Our
            framework suggests a more nuanced view: truth evaluation is an active process involving perspective
            transitions, not a static property.
        </p>
        <p>
            This has implications beyond formal logic. In domains like epistemology and philosophy of language, it
            suggests that truth might be inherently perspective-dependent, especially when self-reference or circular
            reasoning is involved. Rather than seeing this as a limitation or defect, our framework reinterprets it as a
            natural feature of certain types of discourse.
        </p>

        <h3>7.2 The Nature of Self-Reference</h3>
        <p>
            By embedding perspective into the mathematical objects themselves, the framework demonstrates that
            self-reference can be modeled rigorously without invoking inconsistency. What was traditionally viewed as a
            paradox becomes a well-behaved cyclic structure when analyzed from a perspective-dependent viewpoint.
        </p>
        <p>
            This suggests a reevaluation of self-reference in mathematics, logic, and computation. Rather than treating
            self-reference as exceptional or problematic, our framework integrates it naturally into the mathematical
            structure. This aligns with the experience of programmers, who regularly use self-referential data
            structures and recursive functions without encountering paradoxes.
        </p>
        <p>
            The key insight is that self-reference inherently involves a process of perspective shifting. When a
            statement refers to itself, it implicitly invokes a transition from one perspective to another and back
            again. Our framework makes this process explicit through the composition of morphisms, revealing the
            structure that was hidden in the apparent contradiction.
        </p>

        <h3>7.3 Integration of Formal and Informal Reasoning</h3>
        <p>
            The categorical framework bridges rigorous formal mathematics and intuitive ideas about context, viewpoint,
            and self-reference. This synthesis suggests new ways of reconciling formal logic with the inherently
            subjective aspects of meaning and interpretation.
        </p>
        <p>
            Traditionally, formal logic has aimed to eliminate ambiguity and context-dependence, sometimes at the cost
            of expressiveness and natural self-reference. Our framework suggests an alternative approach: embrace
            perspective-dependence as a fundamental aspect of formal systems rather than an obstacle to be overcome.
        </p>
        <p>
            This approach may have applications in computational linguistics, cognitive science, and artificial
            intelligence, where systems must reason about statements with implicit context and perspective. By providing
            a rigorous mathematical foundation for perspective-dependent reasoning, our framework could inform the
            development of more sophisticated AI systems that can handle context-dependent truth and self-reference.
        </p>
        <h3>7.4 Formal Definition of the Meta-Paradox</h3>
        <p>
            We propose a formal characterization of the meta-paradoxical structure underlying many classical paradoxes
            (including Liar Paradox, Berry paradox, Curry's paradox, Russell's Paradox). This unifying framework
            highlights how self-reference,
            circular relations, and an implicit universality assumption combine to create contradictions in various
            domains, and explains how our subjective numbers approach systematically addresses these issues.
        </p>

        <div class="definition-box">
            <h3>Definition 7.4.1 (Meta-Paradox)</h3>
            <p>
                A <em>meta-paradox</em> is a logical structure
                <span class="math">M = (E, R, A)</span> where:
            </p>
            <ol style="font-size: 18px;">
                <li><span class="math"><strong>E</strong></span> is a self-referential entity or universal collection
                    (e.g.,
                    "the set of all sets that do not contain themselves," or "the sentence asserting its own falsity").
                </li>
                <li><span class="math"><strong>R</strong></span> is a relation whose evaluation creates a circular or
                    bidirectional pattern when applied to <span class="math">E</span>, e.g.,
                    <span class="math">R(E) ‚ü∫ ¬¨R(E)</span> or an equivalent loop.
                </li>
                <li><span class="math"><strong>A</strong></span> is an implicit assumption that relation
                    <span class="math">R</span> must yield a single, perspective-independent result in every instance.
                </li>
            </ol>
            <p>
                The contradiction emerges precisely when the self-referential nature of <span class="math">E</span>
                interacts with the circular relation <span class="math">R</span> under assumption <span
                    class="math">A</span>, forcing a logical tension that cannot be resolved within
                perspective-independent frameworks.
            </p>
        </div>

        <p>
            This meta-paradoxical structure directly connects to our subjective numbers framework as follows:
        </p>

        <ul style="font-size: 18px;">
            <li><strong>Element E:</strong> In our framework, the self-referential entity is represented by a morphism
                <span class="math">f<sub>(œÑ(L), p<sub>L</sub> ‚Üí p<sub>L</sub>)</sub></span> that references itself
                through its perspective.
            </li>
            <li><strong>Relation R:</strong> The circular relation corresponds to the composition of a truth evaluation
                morphism with a complement morphism:
                <span class="math">f<sub>(¬¨, p<sub>E</sub> ‚Üí p<sub>L</sub>)</sub> ‚àò f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                        p<sub>E</sub>)</sub></span>.
            </li>
            <li><strong>Assumption A:</strong> The subjective numbers framework directly challenges this assumption by
                making perspectives intrinsic to mathematical objects, thereby replacing the "single
                perspective-independent result" with a perspective-dependent evaluation cycle.</li>
        </ul>

        <div class="definition-box">
            <h3>Definition 7.4.2 (Self-Referential Entity)</h3>
            <p>
                An entity <span class="math">E</span> is <em>self-referential</em> if it directly or indirectly
                references itself in its own definition or exhibits universality properties that implicitly include
                itself. This can take the form of linguistic self-reference (as in the Liar Paradox: "This statement is
                false") or the set-theoretic kind of self-inclusion (as in Russell's Paradox: "The set of all sets that
                do not contain themselves").
            </p>
        </div>

        <div class="definition-box">
            <h3>Definition 7.4.3 (Circular Relation)</h3>
            <p>
                A relation <span class="math">R</span> on <span class="math">E</span> exhibits <em>circularity</em>
                if applying <span class="math">R</span> to <span class="math">E</span> induces a dependency loop of
                the form <span class="math">R(E) ‚ü∫ ¬¨R(E)</span> or a similar pattern of mutual contradiction.
                Classic examples are:
            <ul style="font-size: 18px; margin-left: 1.5em;">
                <li>The Liar statement "L: L is false," yielding <span class="math">œÑ(L) = ¬¨œÑ(L)</span></li>
                <li>Russell's set <span class="math">R = {x | x ‚àâ x}</span>, yielding <span class="math">R ‚àà
                        R
                        ‚ü∫ R ‚àâ R</span></li>
            </ul>
            In both cases, direct evaluation in a perspective-independent framework appears contradictory.
            </p>
        </div>

        <div class="definition-box">
            <h3>Definition 7.4.4 (Universality Assumption)</h3>
            <p>
                The assumption <span class="math">A</span> stipulates that all evaluations of relation <span
                    class="math">R</span> must be absolute, context-independent, and yield a single consistent verdict
                in every instance. In other words, it disallows any perspective- or context-based variation in how
                <span class="math">R</span> is interpreted. This universalizing assumption is what drives paradoxes
                like the Liar and Russell's to contradiction.
            </p>
            <p>
                This assumption corresponds directly to the traditional paradigm in mathematical logic that our
                subjective numbers framework challenges. By making perspective intrinsic to mathematical objects and
                truth evaluation, we replace this universality assumption with a framework that accommodates
                perspective-dependent truth.
            </p>
        </div>

        <div class="theorem">
            <strong>Theorem 7.1 (Resolution of the Meta-Paradox)</strong>:
            The subjective numbers framework resolves the meta-paradox <span class="math">M = (E, R, A)</span> by
            replacing the universality assumption <span class="math">A</span> with perspective-dependent evaluation,
            while preserving the self-referential entity <span class="math">E</span> and the circular relation
            <span class="math">R</span>. This applies equally to the Liar Paradox and to Russell's Paradox.
        </div>
        <div class="complete-proof">
            <p>
                <strong>Proof:</strong> Consider two classic instances of the meta-paradox:
            </p>
            <ul style="font-size: 18px;">
                <li><em>The Liar Paradox</em>, where <span class="math">E</span> is the sentence "This statement is
                    false" and <span class="math">R</span> is "is true," forming
                    <span class="math">œÑ(L) ‚ü∫ ¬¨œÑ(L)</span>.
                </li>
                <li><em>Russell's Paradox</em>, where <span class="math">E</span> is the set
                    <span class="math">{ x | x ‚àâ x }</span> and <span class="math">R</span> is "‚àà" (set
                    membership),
                    forming <span class="math">R ‚àà R ‚ü∫ R ‚àâ R</span>.
                </li>
            </ul>
            </ul>
            <p>
                Both yield the contradiction <span class="math">R(E) = ¬¨R(E)</span> if one assumes
                <span class="math">A</span>: that truth or membership is perspective-independent. In our framework, we
                replace assumption <span class="math">A</span> with the principle that all such relations are
                perspective-dependent. Specifically:
            </p>
            <ol style="font-size: 18px;">
                <li>
                    <strong>Representation of E</strong>:
                    <ul style="font-size: 18px;">

                        <li>For the Liar: we represent "L" as a morphism <span class="math">f<sub>(œÑ(L), p<sub>L</sub> ‚Üí
                                    p<sub>L</sub>)</sub></span>
                            in the category <span class="math">ùì¢ùìù</span>.</li>
                        <li>For Russell's set: we represent <span class="math">R</span> as a subjective number
                            <span class="math">R<sub>(p<sub>R</sub>)</sub></span> whose membership relation is governed
                            by a perspective
                            <span class="math">p<sub>R</sub></span>.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Representation of R</strong>:
                    <ul style="font-size: 18px;">

                        <li>In the Liar case, "is true" becomes the boolean-evaluation morphism, which composes with
                            a complement morphism <span class="math">¬¨</span> to produce a cycle.</li>
                        <li>In Russell's case, "‚àà" becomes a perspective-dependent membership relation
                            <span class="math">M<sub>p<sub>R</sub></sub>(p<sub>R</sub>, p<sub>R</sub>, R, R)</span>
                            that, when forced to evaluate <em>its own
                                membership</em>, invokes a shift to another perspective (often called <span
                                class="math">p<sub>E</sub></span>) and returns the complement value, forming a cycle as
                            well.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Perspective-Dependent Cycle</strong>:
                    <ul style="font-size: 18px;">

                        <li>Instead of concluding <span class="math">œÑ(L) = ¬¨œÑ(L)</span> or
                            <span class="math">R ‚àà R ‚ü∫ R ‚àâ R</span> as absolute contradictions, each case
                            forms
                            a morphism cycle distributed across multiple perspectives (<span class="math">p<sub>L</sub>,
                                p<sub>E</sub></span>
                            or <span class="math">p<sub>R</sub>, p<sub>E</sub></span>), capturing the apparent
                            contradiction as a
                            well-defined
                            oscillation.
                        </li>
                        <li>No single perspective <em>internally</em> asserts both <span class="math">œÑ(L)</span> and
                            <span class="math">¬¨œÑ(L)</span>, or <span class="math">R ‚àà R</span> and
                            <span class="math">R ‚àâ R</span>. The contradiction is "unfolded" into a sequence of
                            perspective shifts that never coincide in one vantage point.
                        </li>
                    </ul>
                </li>
            </ol>
            <p>
                As shown in <strong>Theorem 4.2 (Resolution Without Contradiction)</strong> for the Liar, and in an
                analogous argument for Russell's set membership,
                no single perspective is forced into a direct contradiction. By rejecting the universality assumption
                <span class="math">A</span> yet preserving the self-referential entity <span class="math">E</span> and
                the circular relation <span class="math">R</span>, we transform these classic paradoxes into
                well-defined mathematical cycles. This same principle extends to any meta-paradox of the form
                <span class="math">M = (E, R, A)</span>: once perspective-dependence is built in, the universal,
                context-free requirement that yields contradictions is dissolved. ‚ñ°
            </p>
        </div>


        <div class="key-takeaways">
            <h3>Key Takeaways: Philosophical Implications</h3>
            <ul style="font-size: 18px;">

                <li>Truth in self-referential contexts is inherently perspective-dependent</li>
                <li>Self-reference naturally involves perspective shifting, not contradiction</li>
                <li>The framework bridges formal mathematics with intuitive ideas about context and viewpoint</li>
                <li>Many classical paradoxes share a common meta-paradoxical structure</li>
                <li>Rejecting the universality assumption resolves paradoxes without sacrificing self-reference</li>
            </ul>
        </div>
        <!-- =================== DISTINCTIVE ADVANTAGE SECTION =================== -->
        <h2>8. Using Mathematics Without Restricting Self-Reference</h2>
        <p>
            One of the most striking features of our category-theoretic approach to the liar paradox is that we do
            <em>not</em> modify or abandon classical logic. We do not introduce multi-valued semantics, paraconsistency,
            or artificial language hierarchies that ban self-reference. Instead, we embed perspective directly into our
            mathematical objects and employ established category-theoretic techniques to accommodate self-reference as
            a cyclical, yet contradiction-free, structure.
        </p>

        <p>
            Perhaps the most profound aspect of our approach is that it transforms what has been considered a
            fundamental logical problem for millennia into a stable mathematical structure. Rather than viewing the liar
            paradox as a logical defect that requires weakening our systems, our framework reveals it as a natural cycle
            within category theory, a structure with well-defined properties that can be studied mathematically. This
            transformation isn't merely a notational convenience but represents a substantive mathematical construction:
            the cyclic morphism that captures self-reference is a legitimate object in our category, with precise
            composition properties and provable consistency guarantees. By embedding perspective directly into the
            mathematics, we've shifted the liar paradox from the realm of "logical impossibility" into the domain of
            "structural feature" - demonstrating that category theory provides not just a language for expressing
            logical
            concepts, but machinery powerful enough to resolve paradoxes.
        </p>

        <p>
            This approach offers several distinctive advantages:
        </p>

        <ul style="font-size: 18px;">
            <li>
                <strong>No New Axioms or Logic:</strong> Unlike many prior approaches that propose new inference rules,
                adopt dialetheism, or introduce a third "undefined" truth value, our framework operates within classical
                mathematics (ZFC set theory). The category we construct <span class="math">ùì¢ùìù</span> is a legitimate
                quotient category in the standard sense, requiring no special non-classical axioms.
            </li>
            <li>
                <strong>Retention of Classical Logic Locally:</strong> Each perspective (object in <span
                    class="math">ùì¢ùìù</span>)
                observes ordinary Boolean truth values. There is no departure from bivalence <em>within</em> a single
                vantage point; statements are either true or false locally.
            </li>
            <li>
                <strong>Self-Reference Fully Allowed, Not Banned:</strong> Rather than disallowing a sentence like
                "This statement is false" in one language (as Tarski's hierarchy demands) or forcing it into an
                "ungrounded" gap (Kripke), we embrace its self-reference by encoding it as a cycle of morphisms.
                That cycle never collapses into a contradiction from one perspective's viewpoint.
            </li>
            <li>
                <strong>Purely Mathematical Construction:</strong> Because we use classical category theory,
                equivalence relations, and standard set-theoretic definitions, every step is grounded in established
                mathematics. We do not treat "truth" or "paradox" as exotic phenomena requiring specialized logical
                operations; instead, we relocate perspective as a fundamental property of each mathematical object and
                model the liar paradox as a morphism cycle.
            </li>
            <li>
                <strong>No Global Contradiction:</strong> While the truth of the liar sentence can "oscillate" when
                traversing perspectives, no single vantage sees both <span class="math">A</span> and <span
                    class="math">¬¨A</span> simultaneously, so global contradiction never materializes. This sidesteps
                paradox without limiting self-reference.
            </li>
        </ul>

        <p>
            This represents a methodological inversion where mathematical structures themselves, rather than
            modifications to logic, provide the resolution to a foundational problem in reasoning. The liar paradox need
            not force us to revise logic or forbid self-reference; rather, the apparent contradiction dissolves once we
            recognize that "truth" of a self-referential statement spans multiple perspectives in a cycle, rather than
            collapsing into a single vantage point's direct contradiction.
        </p>

        <!-- =================== CONCLUSION =================== -->
        <h2>9. Conclusion and Future Work</h2>
        <p>
            By applying the subjective numbers framework to the liar paradox, we have shown that
            self-reference need not collapse classical logic into contradiction. Instead, our
            category-theoretic approach transforms the "this statement is false" into a <em>morphism cycle</em>
            that spans different perspectives distributing the apparent contradiction across a loop
            rather than forcing it to manifest in one viewpoint. Within any single perspective, the
            system remains locally classical and free of inconsistency.
        </p>
        <p>
            This perspective-dependent resolution reveals that many so-called "paradoxical" constructions
            are, in fact, stable cycles once one acknowledges the intrinsic role of viewpoint in self-reference.
            The liar paradox's hallmark contradiction emerges only under the assumption that a single,
            universal vantage must assign one consistent truth value. By relaxing that assumption and
            embedding perspective transitions in the mathematics itself, the paradox is recast as a
            legitimate cyclical structure rather than a fundamental breakdown of logic.
        </p>

        <h3>9.1 Summary of Contributions</h3>
        <ul style="font-size: 18px;">

            <li><strong>Direct Application to the Liar Paradox:</strong> We modeled the liar statement
                as a pair of morphisms transitioning from an intrinsic perspective to an external one
                and back again with a logical negation a cycle capturing the "true if and only if false"
                tension.</li>
            <li><strong>Compatibility with Classical Logic:</strong> The liar's contradiction dissolves
                because each local perspective is consistent; no single vantage simultaneously sees
                a statement and its negation as true.</li>
            <li><strong>Relation to Modal and Multi-Valued Logics:</strong> Our method subsumes some
                intuitions from modal or three-valued approaches but stays fully classical at the local
                level, with perspective-laden transitions producing the non-classical effects globally.</li>
            <li><strong>Foundational and Philosophical Insight:</strong> This re-interpretation
                of self-reference as perspective transitions clarifies that paradoxes of circular reference
                do not always indicate logical collapse, but rather the need for a more nuanced framework
                to accommodate cyclical evaluations.</li>
        </ul>

        <h3>9.2 Future Directions</h3>
        <p>
            While our focus has been the liar paradox, many self-referential puzzles (Curry's paradox,
            Berry's paradox, or Russell's paradox) can likewise be addressed via perspective-based
            cycles. Exploring each case in depth is a rich avenue for continued research. Additional
            directions include:
        </p>
        <ul style="font-size: 18px;">

            <li><strong>Selective Fusion:</strong> Generalizing "compatibility tests" to handle more complex
                merges of perspectives, avoiding universal vantage paradoxes.</li>
            <li><strong>Extensions to Non-Boolean Bases:</strong> Replacing standard Boolean truth with
                graded or intuitionistic algebras, to analyze partial truth or uncertain claims while
                retaining perspective-laden cycles.</li>
            <li><strong>Automated Reasoning:</strong> Implementing systems that can parse self-referential
                statements in multi-agent scenarios, consistently evaluating them using subjective numbers.</li>
        </ul>

        <h3>9.3 Final Remarks</h3>
        <p>
            This work underscores that perspective is often the missing ingredient in discussions
            of self-reference. Rather than confining or prohibiting such statements (as in hierarchical
            or multi-valued logics), our category-theoretic construction treats self-reference
            as a cyclical but stable phenomenon. By preserving classical logic locally
            and embedding viewpoint transitions at a structural level, the liar paradox ceases to be
            a contradiction and instead highlights the dynamic interplay between statements and
            the perspectives that evaluate them.
        </p>
        <p>
            We anticipate that further expansions of this framework both theoretically and in
            applications will illuminate how cyclical definitions, context shifts, and partial
            viewpoints can enrich logic, mathematics, and philosophical discourse without
            sacrificing rigor or coherence.
        </p>


        <div class="circle-container">
            <div class="arrow left" onclick="shiftSlide(-1)">&#10094;</div>
            <div class="circle-wrapper">
                <!-- Slider items will be dynamically inserted here -->
            </div>
            <div class="arrow right" onclick="shiftSlide(1)">&#10095;</div>
        </div>
    </article>
    <div class="footer">
        <div class="footer-links">
            <a href="../../index.html">Home</a> |
            <a href="../../about.html">About</a> |
            <a href="../../privacy.html">Privacy Policy</a> |
            <a href="https://www.youtube.com/@CinematicStrawberry">YouTube</a>
        </div><br>
        <hr>

        <p>¬© 2025 Cinematic Strawberry.</p>
    </div>
    <script src="slider.js?v=48"></script>

</body>

</html>